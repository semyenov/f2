{"version":3,"file":"infrastructure-DPkN2pqp.js","names":["config: SubscriptionConfig","subscription: ActiveSubscription<T>"],"sources":["../src/infrastructure/subscriptions/subscriptions.ts","../src/infrastructure/index.ts"],"sourcesContent":["/**\n * # GraphQL Subscription Support for Federation\n *\n * WebSocket-based subscription support for Apollo Federation with Effect-TS patterns.\n * Provides real-time data streaming, event sourcing, and resilient connection management.\n *\n * @example Basic subscription setup\n * ```typescript\n * import { SubscriptionManager } from '@cqrs/federation'\n *\n * const manager = await SubscriptionManager.create({\n *   schema,\n *   transport: 'ws',\n *   endpoint: 'ws://localhost:4000/graphql'\n * })\n *\n * const subscription = manager.subscribe(\n *   'onUserUpdate',\n *   { userId: '123' },\n *   (data) => console.log('Update:', data)\n * )\n * ```\n *\n * @module Subscriptions\n * @since 2.2.0\n */\n\nimport { Effect, Stream, Schedule, Duration, Option } from 'effect'\nimport type { GraphQLSchema } from 'graphql'\n\n/**\n * Subscription transport types\n */\nexport type SubscriptionTransport = 'ws' | 'sse' | 'graphql-ws' | 'socket.io'\n\n/**\n * Subscription configuration\n */\nexport interface SubscriptionConfig {\n  /**\n   * GraphQL schema\n   */\n  schema: GraphQLSchema\n\n  /**\n   * Transport type\n   */\n  transport: SubscriptionTransport\n\n  /**\n   * WebSocket endpoint\n   */\n  endpoint: string\n\n  /**\n   * Connection options\n   */\n  connectionOptions?: {\n    /**\n     * Reconnect on failure\n     */\n    reconnect?: boolean\n\n    /**\n     * Max reconnect attempts\n     */\n    maxReconnectAttempts?: number\n\n    /**\n     * Reconnect delay\n     */\n    reconnectDelay?: Duration.Duration\n\n    /**\n     * Keep-alive interval\n     */\n    keepAlive?: Duration.Duration\n\n    /**\n     * Connection timeout\n     */\n    timeout?: Duration.Duration\n  }\n\n  /**\n   * Authentication\n   */\n  auth?: {\n    /**\n     * Auth token\n     */\n    token?: string\n\n    /**\n     * Custom headers\n     */\n    headers?: Record<string, string>\n  }\n\n  /**\n   * Event handlers\n   */\n  onConnect?: () => void\n  onDisconnect?: (reason?: string) => void\n  onError?: (error: Error) => void\n  onReconnecting?: (attempt: number) => void\n}\n\n/**\n * Subscription state\n */\nexport type SubscriptionState =\n  | { _tag: 'disconnected' }\n  | { _tag: 'connecting' }\n  | { _tag: 'connected'; connectionId: string }\n  | { _tag: 'reconnecting'; attempt: number }\n  | { _tag: 'error'; error: Error }\n\n/**\n * Active subscription\n */\nexport interface ActiveSubscription<T = unknown> {\n  /**\n   * Subscription ID\n   */\n  id: string\n\n  /**\n   * Subscription name\n   */\n  name: string\n\n  /**\n   * Variables\n   */\n  variables?: Record<string, unknown>\n\n  /**\n   * Data stream\n   */\n  stream: Stream.Stream<T, Error>\n\n  /**\n   * Unsubscribe\n   */\n  unsubscribe: () => Effect.Effect<void, Error>\n\n  /**\n   * Subscription metrics\n   */\n  metrics: SubscriptionMetrics\n}\n\n/**\n * Subscription metrics\n */\nexport interface SubscriptionMetrics {\n  /**\n   * Messages received\n   */\n  messagesReceived: number\n\n  /**\n   * Errors occurred\n   */\n  errors: number\n\n  /**\n   * Start time\n   */\n  startTime: Date\n\n  /**\n   * Last message time\n   */\n  lastMessageTime?: Date\n\n  /**\n   * Average latency\n   */\n  averageLatency: number\n\n  /**\n   * Reconnections\n   */\n  reconnections: number\n}\n\n// WebSocket types are globally available in the browser and Node.js environments\n// No need to redeclare them\n\n/**\n * Connection manager with Effect patterns\n */\nclass ConnectionManager {\n  private connection: WebSocket | undefined\n  private state: SubscriptionState = { _tag: 'disconnected' }\n  private reconnectAttempt = 0\n\n  constructor(private readonly config: SubscriptionConfig) {}\n\n  /**\n   * Connect to WebSocket\n   */\n  connect(): Effect.Effect<void, Error> {\n    const self = this\n    return Effect.gen(function* () {\n      if (self.state._tag === 'connected') {\n        return\n      }\n\n      self.state = { _tag: 'connecting' }\n\n      yield* Effect.tryPromise({\n        try: async () => {\n          return new Promise<void>((resolve, reject) => {\n            const ws = new WebSocket(self.config.endpoint)\n\n            ws.onopen = () => {\n              self.connection = ws\n              self.state = {\n                _tag: 'connected',\n                connectionId: Math.random().toString(36).substring(7),\n              }\n              self.reconnectAttempt = 0\n              self.config.onConnect?.()\n              resolve()\n            }\n\n            ws.onerror = event => {\n              const error = new Error(`WebSocket error: ${event.type}`)\n              self.state = { _tag: 'error', error }\n              self.config.onError?.(error)\n              reject(error)\n            }\n\n            ws.onclose = event => {\n              self.state = { _tag: 'disconnected' }\n              self.config.onDisconnect?.(event.reason)\n\n              if (self.config.connectionOptions?.reconnect ?? false) {\n                Effect.runPromise(self.reconnect()).catch(() => {})\n              }\n            }\n\n            // Set connection timeout\n            if (self.config.connectionOptions?.timeout) {\n              setTimeout(() => {\n                if (self.state._tag === 'connecting') {\n                  ws.close()\n                  reject(new Error('Connection timeout'))\n                }\n              }, Duration.toMillis(self.config.connectionOptions.timeout))\n            }\n          })\n        },\n        catch: error => new Error(`Connection failed: ${error}`),\n      })\n\n      // Setup keep-alive if needed\n      if (self.config.connectionOptions?.keepAlive && self.connection) {\n        yield* Effect.fork(self.startKeepAlive())\n      }\n    })\n  }\n\n  /**\n   * Reconnect with backoff\n   */\n  private reconnect(): Effect.Effect<void, Error> {\n    const self = this\n    return Effect.gen(function* () {\n      const maxAttempts = self.config.connectionOptions?.maxReconnectAttempts ?? 5\n\n      if (self.reconnectAttempt >= maxAttempts) {\n        return yield* Effect.fail(new Error('Max reconnection attempts reached'))\n      }\n\n      self.reconnectAttempt++\n      self.state = { _tag: 'reconnecting', attempt: self.reconnectAttempt }\n      self.config.onReconnecting?.(self.reconnectAttempt)\n\n      // Exponential backoff\n      const delay = self.config.connectionOptions?.reconnectDelay ?? Duration.seconds(1)\n      const backoffDelay = Duration.millis(\n        Duration.toMillis(delay) * Math.pow(2, self.reconnectAttempt - 1)\n      )\n\n      yield* Effect.sleep(backoffDelay)\n      yield* self.connect()\n    })\n  }\n\n  /**\n   * Start keep-alive ping\n   */\n  private startKeepAlive(): Effect.Effect<void, never> {\n    const self = this\n    return Effect.gen(function* () {\n      const interval = self.config.connectionOptions?.keepAlive ?? Duration.seconds(30)\n\n      yield* Effect.repeat(\n        Effect.gen(function* () {\n          if (self.connection?.readyState === WebSocket.OPEN) {\n            self.connection.send(JSON.stringify({ type: 'ping' }))\n          }\n        }),\n        Schedule.fixed(interval)\n      )\n    })\n  }\n\n  /**\n   * Send message\n   */\n  send(message: unknown): Effect.Effect<void, Error> {\n    const self = this\n    return Effect.gen(function* () {\n      if (!self.connection || self.connection.readyState !== WebSocket.OPEN) {\n        return yield* Effect.fail(new Error('WebSocket not connected'))\n      }\n\n      self.connection.send(JSON.stringify(message))\n    })\n  }\n\n  /**\n   * Disconnect\n   */\n  disconnect(): Effect.Effect<void, never> {\n    const self = this\n    return Effect.sync(() => {\n      if (self.connection) {\n        self.connection.close()\n        self.connection = undefined\n        self.state = { _tag: 'disconnected' }\n      }\n    })\n  }\n\n  /**\n   * Get state\n   */\n  getState(): SubscriptionState {\n    return this.state\n  }\n}\n\n/**\n * Subscription manager\n */\nexport class SubscriptionManager {\n  private readonly connectionManager: ConnectionManager\n  private readonly subscriptions = new Map<string, ActiveSubscription>()\n\n  constructor(config: SubscriptionConfig) {\n    this.connectionManager = new ConnectionManager(config)\n  }\n\n  /**\n   * Create subscription manager\n   */\n  static async create(config: SubscriptionConfig): Promise<SubscriptionManager> {\n    const manager = new SubscriptionManager(config)\n    await Effect.runPromise(manager.connect())\n    return manager\n  }\n\n  /**\n   * Connect to server\n   */\n  connect(): Effect.Effect<void, Error> {\n    return this.connectionManager.connect()\n  }\n\n  /**\n   * Subscribe to events\n   */\n  subscribe<T = unknown>(\n    subscriptionName: string,\n    variables?: Record<string, unknown>,\n    onData?: (data: T) => void,\n    onError?: (error: Error) => void\n  ): Effect.Effect<ActiveSubscription<T>, Error> {\n    const self = this\n    return Effect.gen(function* () {\n      const subscriptionId = Math.random().toString(36).substring(7)\n\n      // Create subscription stream\n      const stream = Stream.async<T, Error>(emit => {\n        // Mock implementation for now\n        setTimeout(() => {\n          void emit(Effect.fail(Option.none()))\n        }, 100)\n      }).pipe(\n        Stream.tapError(error => Effect.sync(() => onError?.(error))),\n        Stream.tap(data => Effect.sync(() => onData?.(data)))\n      )\n\n      // Create subscription object\n      const subscription: ActiveSubscription<T> = {\n        id: subscriptionId,\n        name: subscriptionName,\n        ...(variables && { variables }),\n        stream,\n        unsubscribe: () => self.unsubscribe(subscriptionId),\n        metrics: {\n          messagesReceived: 0,\n          errors: 0,\n          startTime: new Date(),\n          averageLatency: 0,\n          reconnections: 0,\n        },\n      }\n\n      // Store subscription\n      self.subscriptions.set(subscriptionId, subscription as ActiveSubscription)\n\n      // Send subscription to server\n      yield* self.connectionManager.send({\n        id: subscriptionId,\n        type: 'subscribe',\n        payload: {\n          query: self.buildSubscriptionQuery(subscriptionName),\n          variables,\n        },\n      })\n\n      return subscription\n    })\n  }\n\n  /**\n   * Unsubscribe\n   */\n  unsubscribe(subscriptionId: string): Effect.Effect<void, Error> {\n    const self = this\n    return Effect.gen(function* () {\n      const subscription = self.subscriptions.get(subscriptionId)\n      if (!subscription) {\n        return yield* Effect.fail(new Error(`Subscription ${subscriptionId} not found`))\n      }\n\n      // Send unsubscribe to server\n      yield* self.connectionManager.send({\n        id: subscriptionId,\n        type: 'unsubscribe',\n      })\n\n      // Remove subscription\n      self.subscriptions.delete(subscriptionId)\n    })\n  }\n\n  /**\n   * Unsubscribe all\n   */\n  unsubscribeAll(): Effect.Effect<void, never> {\n    const self = this\n    return Effect.forEach(\n      Array.from(self.subscriptions.keys()),\n      id => self.unsubscribe(id).pipe(Effect.orElseSucceed(() => undefined)),\n      { discard: true }\n    )\n  }\n\n  /**\n   * Disconnect\n   */\n  async disconnect(): Promise<void> {\n    const self = this\n    await Effect.runPromise(\n      Effect.gen(function* () {\n        yield* self.unsubscribeAll()\n        yield* self.connectionManager.disconnect()\n      })\n    )\n  }\n\n  /**\n   * Get connection state\n   */\n  getState(): SubscriptionState {\n    return this.connectionManager.getState()\n  }\n\n  /**\n   * Get active subscriptions\n   */\n  getSubscriptions(): ReadonlyArray<ActiveSubscription> {\n    return Array.from(this.subscriptions.values())\n  }\n\n  /**\n   * Get metrics\n   */\n  getMetrics(): {\n    totalSubscriptions: number\n    totalMessages: number\n    totalErrors: number\n    connectionState: SubscriptionState\n  } {\n    const subscriptions = this.getSubscriptions()\n\n    return {\n      totalSubscriptions: subscriptions.length,\n      totalMessages: subscriptions.reduce((sum, s) => sum + s.metrics.messagesReceived, 0),\n      totalErrors: subscriptions.reduce((sum, s) => sum + s.metrics.errors, 0),\n      connectionState: this.getState(),\n    }\n  }\n\n  /**\n   * Build subscription query\n   */\n  private buildSubscriptionQuery(name: string): string {\n    // This would normally build from schema\n    return `subscription ${name} { ${name} { id } }`\n  }\n}\n\n/**\n * Subscription presets\n */\nexport const SubscriptionPresets = {\n  /**\n   * Development preset\n   */\n  development: (\n    schema: GraphQLSchema,\n    endpoint = 'ws://localhost:4000/graphql'\n  ): SubscriptionConfig => ({\n    schema,\n    transport: 'ws',\n    endpoint,\n    connectionOptions: {\n      reconnect: true,\n      maxReconnectAttempts: 10,\n      reconnectDelay: Duration.seconds(1),\n      keepAlive: Duration.seconds(30),\n      timeout: Duration.seconds(5),\n    },\n    onConnect: () => console.log('🔌 WebSocket connected'),\n    onDisconnect: reason => console.log('🔌 WebSocket disconnected:', reason),\n    onError: error => console.error('❌ WebSocket error:', error),\n    onReconnecting: attempt => console.log(`🔄 Reconnecting... (attempt ${attempt})`),\n  }),\n\n  /**\n   * Production preset\n   */\n  production: (schema: GraphQLSchema, endpoint: string): SubscriptionConfig => ({\n    schema,\n    transport: 'graphql-ws',\n    endpoint,\n    connectionOptions: {\n      reconnect: true,\n      maxReconnectAttempts: 5,\n      reconnectDelay: Duration.seconds(2),\n      keepAlive: Duration.minutes(1),\n      timeout: Duration.seconds(10),\n    },\n  }),\n\n  /**\n   * Testing preset\n   */\n  testing: (schema: GraphQLSchema): SubscriptionConfig => ({\n    schema,\n    transport: 'ws',\n    endpoint: 'ws://localhost:4001/graphql',\n    connectionOptions: {\n      reconnect: false,\n      timeout: Duration.seconds(1),\n    },\n  }),\n}\n\n/**\n * Federation subscription extensions\n */\nexport interface FederationSubscriptionConfig extends SubscriptionConfig {\n  /**\n   * Entity subscriptions\n   */\n  entitySubscriptions?: {\n    /**\n     * Entity type\n     */\n    typename: string\n\n    /**\n     * Subscription events\n     */\n    events: Array<'created' | 'updated' | 'deleted'>\n\n    /**\n     * Filter function\n     */\n    filter?: (entity: unknown) => boolean\n  }[]\n\n  /**\n   * Cross-subgraph subscriptions\n   */\n  crossSubgraph?: {\n    /**\n     * Enable cross-subgraph events\n     */\n    enabled: boolean\n\n    /**\n     * Event propagation delay\n     */\n    propagationDelay?: Duration.Duration\n  }\n}\n\n/**\n * Create federation subscription manager\n */\nexport const createFederationSubscriptionManager = async (\n  config: FederationSubscriptionConfig\n): Promise<SubscriptionManager> => {\n  const manager = await SubscriptionManager.create(config)\n\n  // Setup entity subscriptions\n  if (config.entitySubscriptions) {\n    for (const entityConfig of config.entitySubscriptions) {\n      for (const event of entityConfig.events) {\n        const subscriptionName = `on${entityConfig.typename}${event.charAt(0).toUpperCase() + event.slice(1)}`\n\n        await Effect.runPromise(\n          manager.subscribe(subscriptionName, undefined, data => {\n            if (!entityConfig.filter || entityConfig.filter(data)) {\n              console.log(`📨 ${entityConfig.typename} ${event}:`, data)\n            }\n          })\n        )\n      }\n    }\n  }\n\n  return manager\n}\n","/**\n * Infrastructure Module - Production-ready infrastructure components\n * \n * This module provides enterprise-grade infrastructure including:\n * - Resilience patterns (circuit breakers, error boundaries)\n * - Performance optimizations (caching, batching)\n * - Observability (metrics, tracing, logging)\n * - Real-time subscriptions\n * \n * @module Infrastructure\n * @since 3.0.0\n */\n\n// Resilience patterns\nexport * from './resilience'\n\n// Performance optimizations\nexport * from './performance'\n\n// Observability\n// export * from './observability'\n\n// Subscriptions\nexport * from './subscriptions'"],"mappings":"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"}