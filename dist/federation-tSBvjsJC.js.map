{"version":3,"file":"federation-tSBvjsJC.js","names":["config: MeshIntegrationConfig"],"sources":["../src/federation/entities/mesh.ts","../src/federation/index.ts"],"sourcesContent":["/**\n * # GraphQL Mesh Integration for Federation\n *\n * Integrates GraphQL Mesh capabilities with Apollo Federation, enabling\n * unified access to REST APIs, databases, gRPC services, and other data sources\n * through a federated GraphQL layer.\n *\n * @example Basic mesh integration\n * ```typescript\n * import { MeshIntegration } from '@cqrs/federation'\n *\n * const mesh = await MeshIntegration.create({\n *   sources: [\n *     { type: 'openapi', name: 'users', spec: './openapi.yaml' },\n *     { type: 'grpc', name: 'products', proto: './products.proto' },\n *     { type: 'postgres', name: 'orders', connectionString: 'postgres://...' }\n *   ],\n *   federation: {\n *     entities: [userEntity, productEntity],\n *     services: ['http://gateway:4000']\n *   }\n * })\n * ```\n *\n * @module Mesh\n * @since 2.3.0\n */\n\nimport { Effect, Duration, Schedule, pipe } from 'effect'\nimport type { GraphQLSchema } from 'graphql'\nimport { buildSchema, printSchema } from 'graphql'\nimport type { FederationEntity, ServiceDefinition } from '../../runtime/core/types/types.js'\n\n/**\n * Mesh source types\n */\nexport type MeshSourceType =\n  | 'openapi'\n  | 'graphql'\n  | 'grpc'\n  | 'soap'\n  | 'odata'\n  | 'thrift'\n  | 'postgres'\n  | 'mysql'\n  | 'mongodb'\n  | 'redis'\n  | 'elasticsearch'\n  | 'neo4j'\n  | 'json-schema'\n\n/**\n * Mesh source configuration\n */\nexport interface MeshSource {\n  /**\n   * Source type\n   */\n  type: MeshSourceType\n\n  /**\n   * Source name\n   */\n  name: string\n\n  /**\n   * Source-specific configuration\n   */\n  config: Record<string, unknown>\n\n  /**\n   * Transform configuration\n   */\n  transforms?: MeshTransform[]\n\n  /**\n   * Cache configuration\n   */\n  cache?: {\n    /**\n     * TTL in seconds\n     */\n    ttl?: number\n\n    /**\n     * Invalidation rules\n     */\n    invalidate?: {\n      /**\n       * Time-based invalidation\n       */\n      ttl?: Duration.Duration\n\n      /**\n       * Event-based invalidation\n       */\n      events?: string[]\n    }\n  }\n}\n\n/**\n * Mesh transformation types\n */\nexport interface MeshTransform {\n  /**\n   * Transform type\n   */\n  type: 'rename' | 'filter' | 'prefix' | 'suffix' | 'encapsulate' | 'federation'\n\n  /**\n   * Transform configuration\n   */\n  config: Record<string, unknown>\n}\n\n/**\n * Mesh integration configuration\n */\nexport interface MeshIntegrationConfig {\n  /**\n   * Data sources\n   */\n  sources: MeshSource[]\n\n  /**\n   * Federation configuration\n   */\n  federation?: {\n    /**\n     * Federation entities\n     */\n    entities?: FederationEntity<unknown, unknown, unknown, unknown>[]\n\n    /**\n     * Federation services\n     */\n    services?: ServiceDefinition[]\n\n    /**\n     * Enable auto-federation\n     */\n    autoFederation?: boolean\n  }\n\n  /**\n   * Mesh configuration\n   */\n  mesh?: {\n    /**\n     * Enable playground\n     */\n    playground?: boolean\n\n    /**\n     * Port\n     */\n    port?: number\n\n    /**\n     * CORS configuration\n     */\n    cors?: {\n      origin?: string | string[]\n      credentials?: boolean\n    }\n\n    /**\n     * Rate limiting\n     */\n    rateLimit?: {\n      max: number\n      window: Duration.Duration\n    }\n  }\n\n  /**\n   * Plugins\n   */\n  plugins?: MeshPlugin[]\n\n  /**\n   * Error handling\n   */\n  errorHandling?: {\n    /**\n     * Mask errors in production\n     */\n    maskErrors?: boolean\n\n    /**\n     * Custom error formatter\n     */\n    formatter?: (error: Error) => Record<string, unknown>\n  }\n}\n\n/**\n * Mesh plugin interface\n */\nexport interface MeshPlugin {\n  /**\n   * Plugin name\n   */\n  name: string\n\n  /**\n   * Plugin configuration\n   */\n  config?: Record<string, unknown>\n\n  /**\n   * Plugin hooks\n   */\n  hooks?: {\n    /**\n     * Before request hook\n     */\n    beforeRequest?: (context: unknown) => Effect.Effect<void, Error>\n\n    /**\n     * After request hook\n     */\n    afterRequest?: (context: unknown, result: unknown) => Effect.Effect<void, Error>\n\n    /**\n     * On error hook\n     */\n    onError?: (error: Error) => Effect.Effect<void, never>\n  }\n}\n\n/**\n * Mesh runtime instance\n */\nexport interface MeshInstance {\n  /**\n   * GraphQL schema\n   */\n  schema: GraphQLSchema\n\n  /**\n   * Execute query\n   */\n  execute: (query: string, variables?: Record<string, unknown>) => Effect.Effect<unknown, Error>\n\n  /**\n   * Get metrics\n   */\n  getMetrics: () => MeshMetrics\n\n  /**\n   * Refresh sources\n   */\n  refresh: (sourceName?: string) => Effect.Effect<void, Error>\n\n  /**\n   * Stop mesh\n   */\n  stop: () => Effect.Effect<void, never>\n}\n\n/**\n * Mesh metrics\n */\nexport interface MeshMetrics {\n  /**\n   * Total requests\n   */\n  requests: number\n\n  /**\n   * Cache hits\n   */\n  cacheHits: number\n\n  /**\n   * Cache misses\n   */\n  cacheMisses: number\n\n  /**\n   * Average latency\n   */\n  avgLatency: number\n\n  /**\n   * Source metrics\n   */\n  sources: Record<\n    string,\n    {\n      requests: number\n      errors: number\n      avgLatency: number\n    }\n  >\n}\n\n/**\n * Source adapter interface\n */\ninterface SourceAdapter {\n  /**\n   * Load schema from source\n   */\n  loadSchema(): Effect.Effect<GraphQLSchema, Error>\n\n  /**\n   * Execute query against source\n   */\n  execute(query: string, variables?: Record<string, unknown>): Effect.Effect<unknown, Error>\n\n  /**\n   * Get source health\n   */\n  health(): Effect.Effect<boolean, Error>\n}\n\n/**\n * OpenAPI source adapter\n */\nclass OpenAPIAdapter implements SourceAdapter {\n  constructor(_config: Record<string, unknown>) {}\n\n  loadSchema(): Effect.Effect<GraphQLSchema, Error> {\n    return pipe(\n      Effect.try(() => {\n        // Mock implementation - would normally parse OpenAPI spec\n        const schemaSDL = `\n          type Query {\n            users: [User]\n            user(id: ID!): User\n          }\n          \n          type User {\n            id: ID!\n            name: String!\n            email: String!\n          }\n        `\n\n        return buildSchema(schemaSDL)\n      }),\n      Effect.mapError(error => new Error(`Failed to load OpenAPI schema: ${error}`))\n    )\n  }\n\n  execute(_query: string, _variables?: Record<string, unknown>): Effect.Effect<unknown, Error> {\n    return Effect.succeed({\n      data: { users: [] },\n    })\n  }\n\n  health(): Effect.Effect<boolean, Error> {\n    return Effect.succeed(true)\n  }\n}\n\n/**\n * gRPC source adapter\n */\nclass GRPCAdapter implements SourceAdapter {\n  constructor(_config: Record<string, unknown>) {}\n\n  loadSchema(): Effect.Effect<GraphQLSchema, Error> {\n    return pipe(\n      Effect.try(() => {\n        // Mock implementation - would normally parse proto file\n        const schemaSDL = `\n          type Query {\n            products: [Product]\n            product(id: ID!): Product\n          }\n          \n          type Product {\n            id: ID!\n            name: String!\n            price: Float!\n          }\n        `\n\n        return buildSchema(schemaSDL)\n      }),\n      Effect.mapError(error => new Error(`Failed to load gRPC schema: ${error}`))\n    )\n  }\n\n  execute(_query: string, _variables?: Record<string, unknown>): Effect.Effect<unknown, Error> {\n    return Effect.succeed({\n      data: { products: [] },\n    })\n  }\n\n  health(): Effect.Effect<boolean, Error> {\n    return Effect.succeed(true)\n  }\n}\n\n/**\n * Database source adapter\n */\nclass DatabaseAdapter implements SourceAdapter {\n  constructor(_type: string, _config: Record<string, unknown>) {}\n\n  loadSchema(): Effect.Effect<GraphQLSchema, Error> {\n    return pipe(\n      Effect.try(() => {\n        // Mock implementation - would normally introspect database\n        const schemaSDL = `\n          type Query {\n            orders: [Order]\n            order(id: ID!): Order\n          }\n          \n          type Order {\n            id: ID!\n            customerId: ID!\n            total: Float!\n            status: String!\n          }\n        `\n\n        return buildSchema(schemaSDL)\n      }),\n      Effect.mapError(error => new Error(`Failed to load database schema: ${error}`))\n    )\n  }\n\n  execute(_query: string, _variables?: Record<string, unknown>): Effect.Effect<unknown, Error> {\n    return Effect.succeed({\n      data: { orders: [] },\n    })\n  }\n\n  health(): Effect.Effect<boolean, Error> {\n    return Effect.succeed(true)\n  }\n}\n\n/**\n * Mesh integration class\n */\nexport class MeshIntegration {\n  private readonly adapters: Map<string, SourceAdapter> = new Map()\n  private schema: GraphQLSchema | undefined\n  private readonly metrics: MeshMetrics = {\n    requests: 0,\n    cacheHits: 0,\n    cacheMisses: 0,\n    avgLatency: 0,\n    sources: {},\n  }\n\n  constructor(private readonly config: MeshIntegrationConfig) {}\n\n  /**\n   * Create mesh integration\n   */\n  static async create(config: MeshIntegrationConfig): Promise<MeshInstance> {\n    const integration = new MeshIntegration(config)\n    await Effect.runPromise(integration.initialize())\n\n    return {\n      schema: integration.schema!,\n      execute: (query, variables) => integration.execute(query, variables),\n      getMetrics: () => integration.metrics,\n      refresh: sourceName => integration.refresh(sourceName),\n      stop: () => integration.stop(),\n    }\n  }\n\n  /**\n   * Initialize mesh\n   */\n  private initialize(): Effect.Effect<void, Error> {\n    const self = this\n\n    return pipe(\n      // Create adapters for each source\n      Effect.forEach(self.config.sources, source =>\n        pipe(\n          self.createAdapter(source),\n          Effect.tap(adapter =>\n            Effect.sync(() => {\n              self.adapters.set(source.name, adapter)\n              self.metrics.sources[source.name] = {\n                requests: 0,\n                errors: 0,\n                avgLatency: 0,\n              }\n            })\n          )\n        )\n      ),\n      // Load and merge schemas\n      Effect.flatMap(() => self.loadSchemas()),\n      // Apply federation transforms if configured\n      Effect.flatMap(() =>\n        (self.config.federation?.autoFederation ?? false)\n          ? self.applyFederationTransforms()\n          : Effect.succeed(undefined)\n      ),\n      // Start health monitoring\n      Effect.flatMap(() => Effect.fork(self.startHealthMonitoring())),\n      Effect.map(() => undefined)\n    )\n  }\n\n  /**\n   * Create adapter for source\n   */\n  private createAdapter(source: MeshSource): Effect.Effect<SourceAdapter, Error> {\n    return pipe(\n      Effect.sync(() => {\n        switch (source.type) {\n          case 'openapi':\n            return new OpenAPIAdapter(source.config)\n\n          case 'grpc':\n            return new GRPCAdapter(source.config)\n\n          case 'postgres':\n          case 'mysql':\n          case 'mongodb':\n            return new DatabaseAdapter(source.type, source.config)\n\n          default:\n            return null\n        }\n      }),\n      Effect.flatMap(adapter =>\n        adapter\n          ? Effect.succeed(adapter)\n          : Effect.fail(new Error(`Unsupported source type: ${source.type}`))\n      )\n    )\n  }\n\n  /**\n   * Load and merge schemas\n   */\n  private loadSchemas(): Effect.Effect<void, Error> {\n    const self = this\n\n    return pipe(\n      Effect.forEach(Array.from(self.adapters.entries()), ([_name, adapter]) =>\n        adapter.loadSchema()\n      ),\n      Effect.map(schemas => {\n        // Merge schemas (simplified - would use stitching in practice)\n        self.schema = schemas[0] // Mock merge\n      })\n    )\n  }\n\n  /**\n   * Apply federation transforms\n   */\n  private applyFederationTransforms(): Effect.Effect<void, Error> {\n    const self = this\n\n    return pipe(\n      Effect.sync(() => self.schema),\n      Effect.flatMap(schema =>\n        schema ? Effect.succeed(schema) : Effect.fail(new Error('Schema not loaded'))\n      ),\n      Effect.map(schema => {\n        // Add federation directives\n        const federatedSDL = `\n          ${printSchema(schema)}\n          \n          extend type Query {\n            _entities(representations: [_Any!]!): [_Entity]!\n            _service: _Service!\n          }\n          \n          scalar _Any\n          union _Entity\n          \n          type _Service {\n            sdl: String!\n          }\n        `\n\n        self.schema = buildSchema(federatedSDL)\n      })\n    )\n  }\n\n  /**\n   * Execute query\n   */\n  private execute(\n    query: string,\n    variables?: Record<string, unknown>\n  ): Effect.Effect<unknown, Error> {\n    const self = this\n    const startTime = Date.now()\n\n    return pipe(\n      Effect.sync(() => {\n        self.metrics.requests++\n        return self.determineSource(query)\n      }),\n      Effect.flatMap(sourceName => {\n        const adapter = self.adapters.get(sourceName)\n        return adapter\n          ? adapter.execute(query, variables)\n          : Effect.fail(new Error(`No adapter for source: ${sourceName}`))\n      }),\n      Effect.tap(() =>\n        Effect.sync(() => {\n          const latency = Date.now() - startTime\n          self.updateMetrics('default', latency, false)\n        })\n      ),\n      Effect.tapError(() =>\n        Effect.sync(() => {\n          const latency = Date.now() - startTime\n          self.updateMetrics('default', latency, true)\n        })\n      )\n    )\n  }\n\n  /**\n   * Determine source from query\n   */\n  private determineSource(query: string): string {\n    // Simple implementation - would parse query AST in practice\n    if (query.includes('users')) return 'users'\n    if (query.includes('products')) return 'products'\n    if (query.includes('orders')) return 'orders'\n    return Array.from(this.adapters.keys())[0] ?? 'default'\n  }\n\n  /**\n   * Update metrics\n   */\n  private updateMetrics(sourceName: string, latency: number, isError: boolean): void {\n    const sourceMetrics = this.metrics.sources[sourceName]\n    if (sourceMetrics) {\n      sourceMetrics.requests++\n      if (isError) sourceMetrics.errors++\n      sourceMetrics.avgLatency =\n        (sourceMetrics.avgLatency * (sourceMetrics.requests - 1) + latency) / sourceMetrics.requests\n    }\n\n    this.metrics.avgLatency =\n      (this.metrics.avgLatency * (this.metrics.requests - 1) + latency) / this.metrics.requests\n  }\n\n  /**\n   * Refresh sources\n   */\n  private refresh(sourceName?: string): Effect.Effect<void, Error> {\n    const self = this\n\n    return sourceName != null\n      ? pipe(\n          Effect.sync(() => self.adapters.get(sourceName)),\n          Effect.flatMap(adapter =>\n            adapter\n              ? adapter.loadSchema()\n              : Effect.fail(new Error(`Source not found: ${sourceName}`))\n          ),\n          Effect.map(() => undefined)\n        )\n      : self.loadSchemas()\n  }\n\n  /**\n   * Start health monitoring\n   */\n  private startHealthMonitoring(): Effect.Effect<void, never> {\n    const self = this\n\n    return Effect.repeat(\n      pipe(\n        Effect.forEach(Array.from(self.adapters.entries()), ([name, adapter]) =>\n          pipe(\n            adapter.health(),\n            Effect.orElseSucceed(() => false),\n            Effect.tap(isHealthy =>\n              !isHealthy\n                ? Effect.sync(() => console.warn(`⚠️  Source ${name} is unhealthy`))\n                : Effect.succeed(undefined)\n            )\n          )\n        ),\n        Effect.map(() => undefined)\n      ),\n      Schedule.fixed(Duration.seconds(30))\n    )\n  }\n\n  /**\n   * Stop mesh\n   */\n  private stop(): Effect.Effect<void, never> {\n    return Effect.sync(() => {\n      console.log('🛑 Mesh integration stopped')\n    })\n  }\n}\n\n/**\n * Mesh presets\n */\nexport const MeshPresets = {\n  /**\n   * Microservices preset\n   */\n  microservices: (\n    services: Array<{ name: string; url: string; type: 'graphql' | 'rest' }>\n  ): MeshIntegrationConfig => ({\n    sources: services.map(service => ({\n      type: service.type === 'rest' ? 'openapi' : 'graphql',\n      name: service.name,\n      config: { endpoint: service.url },\n      cache: { ttl: 60 },\n    })),\n    federation: { autoFederation: true },\n    mesh: {\n      playground: true,\n      port: 4000,\n      rateLimit: { max: 1000, window: Duration.minutes(1) },\n    },\n  }),\n\n  /**\n   * Database federation preset\n   */\n  databases: (\n    databases: Array<{ name: string; type: 'postgres' | 'mysql' | 'mongodb'; connection: string }>\n  ): MeshIntegrationConfig => ({\n    sources: databases.map(db => ({\n      type: db.type,\n      name: db.name,\n      config: { connectionString: db.connection },\n      transforms: [{ type: 'federation', config: { version: '2.0' } }],\n    })),\n    federation: { autoFederation: true },\n    errorHandling: { maskErrors: true },\n  }),\n\n  /**\n   * API gateway preset\n   */\n  apiGateway: (apis: Array<{ name: string; spec: string }>): MeshIntegrationConfig => ({\n    sources: apis.map(api => ({\n      type: 'openapi',\n      name: api.name,\n      config: { spec: api.spec },\n      transforms: [\n        { type: 'prefix', config: { value: api.name } },\n        { type: 'encapsulate', config: { name: api.name } },\n      ],\n    })),\n    mesh: {\n      playground: true,\n      cors: { origin: '*', credentials: true },\n    },\n    plugins: [\n      {\n        name: 'auth',\n        config: { type: 'jwt' },\n      },\n      {\n        name: 'monitoring',\n        config: { provider: 'prometheus' },\n      },\n    ],\n  }),\n}\n\n/**\n * Mesh utilities\n */\nexport const MeshUtils = {\n  /**\n   * Convert OpenAPI to GraphQL schema\n   */\n  openAPIToGraphQL: (_spec: string): Effect.Effect<GraphQLSchema, Error> => {\n    return pipe(\n      Effect.try(() =>\n        buildSchema(`\n          type Query {\n            api: String\n          }\n        `)\n      ),\n      Effect.mapError(error => new Error(`Failed to convert OpenAPI: ${error}`))\n    )\n  },\n\n  /**\n   * Convert proto to GraphQL schema\n   */\n  protoToGraphQL: (_proto: string): Effect.Effect<GraphQLSchema, Error> => {\n    return pipe(\n      Effect.try(() =>\n        buildSchema(`\n          type Query {\n            service: String\n          }\n        `)\n      ),\n      Effect.mapError(error => new Error(`Failed to convert proto: ${error}`))\n    )\n  },\n\n  /**\n   * Introspect database schema\n   */\n  introspectDatabase: (_connection: string): Effect.Effect<GraphQLSchema, Error> => {\n    return pipe(\n      Effect.try(() =>\n        buildSchema(`\n          type Query {\n            tables: [String]\n          }\n        `)\n      ),\n      Effect.mapError(error => new Error(`Failed to introspect database: ${error}`))\n    )\n  },\n}\n","/**\n * ## Federation Components\n *\n * This module provides the core federation components for composing, managing,\n * and optimizing Apollo Federation 2.x services. It includes schema composition,\n * subgraph management, error boundaries, and performance optimizations.\n *\n * ### ⚡ Federation Features\n *\n * - **Schema Composition**: Automated federated schema composition with hot reloading\n * - **Subgraph Management**: Service discovery, health monitoring, and lifecycle management\n * - **Error Boundaries**: Circuit breakers, timeout handling, and fault tolerance\n * - **Performance**: Query plan caching, DataLoader batching, and execution optimization\n *\n * @example Complete federation setup\n * ```typescript\n * import {\n *   FederationComposer,\n *   SubgraphManagement,\n *   FederationErrorBoundaries,\n *   PerformanceOptimizations\n * } from '@cqrs/federation'\n * import { Effect, Duration } from 'effect'\n *\n * const setupFederation = Effect.gen(function* () {\n *   // Registry with health monitoring\n *   const registry = yield* SubgraphManagement.createRegistry({\n *     services: [\n *       { id: 'users', url: 'http://user-service:4001' },\n *       { id: 'products', url: 'http://product-service:4002' }\n *     ],\n *     healthCheckInterval: Duration.seconds(30)\n *   })\n *\n *   // Error boundaries with circuit breakers\n *   const errorBoundary = yield* FederationErrorBoundaries.createBoundary({\n *     circuitBreakerConfig: {\n *       failureThreshold: 5,\n *       resetTimeout: Duration.seconds(30)\n *     }\n *   })\n *\n *   // Performance optimizations\n *   const performance = yield* PerformanceOptimizations.createOptimizedExecutor({\n *     queryPlanCache: { maxSize: 1000 },\n *     dataLoaderConfig: { maxBatchSize: 100 }\n *   })\n *\n *   // Compose federated schema\n *   return yield* FederationComposer.create({\n *     entities: [userEntity, productEntity],\n *     registry,\n *     errorBoundary,\n *     performance\n *   })\n * })\n * ```\n *\n * @since 2.0.0\n * @category Federation Components\n */\n// Composition\nexport * from './composition'\n\n// Subgraph management\nexport * from './subgraphs'\n\n// Entity management\nexport * from './entities'\n\n// Directives (when implemented)\n// export * from './directives'\n"],"mappings":"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"}