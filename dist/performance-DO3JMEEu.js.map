{"version":3,"file":"performance-DO3JMEEu.js","names":["successful: SubgraphResult[]","failed: SubgraphResult[]","state: CircuitBreakerState","lastFailureTime: number | null","metricsBuffer: Array<{ subgraphId: string; metrics: unknown }>","metricsFlushTimer: ReturnType<typeof setTimeout> | null","baseError: TransformedError","config","executionMetrics: ExecutionMetrics[]","cacheOperations: CacheOperation[]","execError: ExecutionError"],"sources":["../src/infrastructure/resilience/error-boundaries.ts","../src/infrastructure/performance/performance.ts"],"sourcesContent":["/**\n * Federation Error Boundaries and Resilience Patterns\n *\n * Comprehensive error handling and resilience system for federated GraphQL deployments,\n * providing circuit breakers, partial failure handling, timeout management, and\n * sophisticated error transformation strategies.\n *\n * ## üõ°Ô∏è Resilience Patterns\n *\n * ### Circuit Breaker Pattern\n * Implements the circuit breaker pattern to prevent cascading failures:\n * - **Closed**: Normal operation, requests flow through\n * - **Open**: Circuit trips, requests fail-fast to prevent resource exhaustion\n * - **Half-Open**: Test phase, limited requests to check service recovery\n *\n * ### Partial Failure Handling\n * Gracefully handles subgraph failures with configurable strategies:\n * - **Fail-fast**: Fail entire request if critical subgraphs fail\n * - **Graceful degradation**: Return partial results with null fields for failed subgraphs\n * - **Fallback values**: Use predefined fallback data when subgraphs are unavailable\n *\n * ### Error Transformation\n * Sophisticated error processing and client-safe error messages:\n * - **Error sanitization**: Remove sensitive information from client-facing errors\n * - **Error correlation**: Link errors across distributed traces\n * - **Error categorization**: Classify errors by type, severity, and retry-ability\n *\n * ## ‚ö° Performance Features\n * - **Timeout Management**: Per-subgraph timeout configuration with fallback strategies\n * - **Request Hedging**: Duplicate requests to slow subgraphs for improved latency\n * - **Load Shedding**: Reject requests when system is under heavy load\n * - **Bulk Operations**: Batch multiple subgraph requests for efficiency\n *\n * @example Basic error boundary setup\n * ```typescript\n * import { FederationErrorBoundaries } from '@cqrs/federation'\n * import { Duration } from 'effect'\n *\n * const errorBoundary = yield* FederationErrorBoundaries.create({\n *   subgraphTimeouts: {\n *     'user-service': Duration.seconds(5),\n *     'product-service': Duration.seconds(3),\n *     'order-service': Duration.seconds(10)\n *   },\n *   circuitBreakerConfig: {\n *     failureThreshold: 5,        // Trip after 5 consecutive failures\n *     resetTimeout: Duration.seconds(30),  // Try again after 30s\n *     halfOpenMaxCalls: 3         // Allow 3 test calls in half-open state\n *   },\n *   partialFailureHandling: {\n *     allowPartialFailure: true,\n *     criticalSubgraphs: ['user-service'],  // These must succeed\n *     fallbackValues: {\n *       'product-service': { products: [] },\n *       'recommendation-service': { recommendations: [] }\n *     }\n *   },\n *   errorTransformation: {\n *     sanitizeErrors: true,       // Remove stack traces in production\n *     includeStackTrace: false,   // Don't leak internal details\n *     customTransformer: (error) => ({\n *       message: 'Service temporarily unavailable',\n *       code: 'SERVICE_UNAVAILABLE',\n *       timestamp: new Date().toISOString()\n *     })\n *   }\n * })\n * ```\n *\n * @example Advanced circuit breaker usage\n * ```typescript\n * const createCircuitBreaker = (subgraphId: string) =>\n *   FederationErrorBoundaries.createCircuitBreaker({\n *     failureThreshold: 10,\n *     resetTimeout: Duration.minutes(2),\n *     halfOpenMaxCalls: 5\n *   }).pipe(\n *     Effect.tap(breaker =>\n *       FederationLogger.flatMap(logger =>\n *         logger.info('Circuit breaker created', {\n *           subgraph: subgraphId,\n *           config: {\n *             failureThreshold: 10,\n *             resetTimeoutMs: Duration.toMillis(Duration.minutes(2))\n *           }\n *         })\n *       )\n *     )\n *   )\n *\n * const protectedSubgraphCall = (breaker: CircuitBreaker, operation: Effect.Effect<Data, Error>) =>\n *   breaker.protect(operation).pipe(\n *     Effect.catchTag('CircuitBreakerError', error =>\n *       Match.value(error.state).pipe(\n *         Match.when('open', () =>\n *           Effect.succeed({ data: null, errors: ['Service temporarily unavailable'] })\n *         ),\n *         Match.when('half-open', () =>\n *           Effect.retry(operation, { times: 1, delay: Duration.seconds(1) })\n *         ),\n *         Match.orElse(() => Effect.fail(error))\n *       )\n *     )\n *   )\n * ```\n *\n * @example Partial failure handling strategies\n * ```typescript\n * const handlePartialFailure = (results: SubgraphResults) =>\n *   Effect.gen(function* () {\n *     const boundary = yield* ErrorBoundary\n *     const logger = yield* FederationLogger\n *\n *     // Separate successful and failed results\n *     const successful = Object.entries(results)\n *       .filter(([_, result]) => result.success)\n *     const failed = Object.entries(results)\n *       .filter(([_, result]) => !result.success)\n *\n *     if (failed.length > 0) {\n *       yield* logger.warn('Partial subgraph failures detected', {\n *         failedSubgraphs: failed.map(([id]) => id),\n *         successfulSubgraphs: successful.map(([id]) => id)\n *       })\n *\n *       // Check if any critical subgraphs failed\n *       const criticalFailures = failed.filter(([id]) =>\n *         config.partialFailureHandling.criticalSubgraphs?.includes(id)\n *       )\n *\n *       if (criticalFailures.length > 0) {\n *         return yield* Effect.fail(\n *           ErrorFactory.federation(\n *             'Critical subgraph failure',\n *             criticalFailures[0][0],\n *             'query'\n *           )\n *         )\n *       }\n *     }\n *\n *     // Process partial failure with fallback values\n *     return yield* boundary.handlePartialFailure(results)\n *   })\n * ```\n *\n * @example Error transformation and sanitization\n * ```typescript\n * const createProductionErrorBoundary = () =>\n *   FederationErrorBoundaries.create({\n *     errorTransformation: {\n *       sanitizeErrors: true,\n *       includeStackTrace: false,\n *       customTransformer: (error, context) => {\n *         // Log full error details internally\n *         Effect.runSync(\n *           FederationLogger.flatMap(logger =>\n *             logger.error('Subgraph error occurred', {\n *               subgraph: context.subgraphId,\n *               fieldPath: context.fieldPath,\n *               error: error.message,\n *               stack: error.stack,\n *               operationType: context.operationType\n *             })\n *           )\n *         )\n *\n *         // Return sanitized error for client\n *         return {\n *           message: Match.value(error).pipe(\n *             Match.tag('TimeoutError', () => 'Request timeout'),\n *             Match.tag('CircuitBreakerError', () => 'Service temporarily unavailable'),\n *             Match.tag('ValidationError', err => `Invalid input: ${err.field}`),\n *             Match.orElse(() => 'Internal server error')\n *           ),\n *           code: error._tag,\n *           path: context.fieldPath,\n *           timestamp: context.timestamp.toISOString()\n *         }\n *       }\n *     }\n *   })\n * ```\n *\n * @example Timeout and retry strategies\n * ```typescript\n * const resilientSubgraphExecution = (subgraphId: string, operation: GraphQLOperation) =>\n *   Effect.gen(function* () {\n *     const config = yield* FederationConfigService\n *     const timeout = config.errorBoundaries.subgraphTimeouts[subgraphId] ?? Duration.seconds(30)\n *\n *     return yield* executeSubgraphOperation(operation).pipe(\n *       Effect.timeout(timeout),\n *       Effect.retry({\n *         times: 3,\n *         delay: (attempt) => Duration.millis(100 * Math.pow(2, attempt)) // Exponential backoff\n *       }),\n *       Effect.catchAll(error =>\n *         Match.value(error).pipe(\n *           Match.tag('TimeoutError', () =>\n *             Effect.succeed({\n *               data: null,\n *               errors: [{ message: 'Request timeout', path: operation.fieldPath }]\n *             })\n *           ),\n *           Match.orElse(() => Effect.fail(error))\n *         )\n *       )\n *     )\n *   })\n * ```\n *\n * @example Health-based circuit breaker\n * ```typescript\n * const healthAwareCircuitBreaker = (subgraphId: string) =>\n *   Effect.gen(function* () {\n *     const registry = yield* SubgraphRegistry\n *     const breaker = yield* createCircuitBreaker(subgraphId)\n *\n *     // Monitor subgraph health and adjust circuit breaker\n *     const healthCheck = yield* Effect.repeat(\n *       registry.health(subgraphId).pipe(\n *         Effect.tap(health =>\n *           Match.value(health.status).pipe(\n *             Match.when('unhealthy', () =>\n *               // Force circuit open if health check fails\n *               Effect.sync(() => breaker.forceOpen())\n *             ),\n *             Match.when('healthy', () =>\n *               // Reset circuit if health improves\n *               Effect.sync(() => breaker.reset())\n *             ),\n *             Match.orElse(() => Effect.void)\n *           )\n *         )\n *       ),\n *       {\n *         schedule: Schedule.spaced(Duration.seconds(10))\n *       }\n *     ).pipe(Effect.fork)\n *\n *     return breaker\n *   })\n * ```\n *\n * @category Error Handling & Resilience\n * @see {@link https://martinfowler.com/bliki/CircuitBreaker.html | Circuit Breaker Pattern}\n * @see {@link https://www.apollographql.com/docs/federation/errors/ | Federation Error Handling}\n */\n\nimport type {\n  CircuitBreaker,\n  CircuitBreakerConfig,\n  CircuitBreakerError,\n  CircuitBreakerMetrics,\n  CircuitBreakerState,\n  ErrorBoundaryConfig,\n  ErrorTransformationConfig,\n  FederationError,\n  PartialFailureConfig,\n} from '@runtime/core'\nimport { type CompositionError, ErrorFactory } from '@runtime/core'\nimport { Duration, Effect, pipe } from 'effect'\nimport type { GraphQLResolveInfo } from 'graphql'\n\n/**\n * GraphQL resolver function type\n * @category Error Handling\n */\nexport type GraphQLResolver = (\n  parent: unknown,\n  args: unknown,\n  context: unknown,\n  info: GraphQLResolveInfo\n) => Promise<unknown>\n\n/**\n * Bounded resolver with error handling\n */\ntype BoundedResolver = GraphQLResolver\n\n/**\n * Error boundary instance\n */\nexport interface ErrorBoundary {\n  readonly wrapResolver: (subgraphId: string, resolver: GraphQLResolver) => BoundedResolver\n  readonly handlePartialFailure: (\n    results: SubgraphResults\n  ) => Effect.Effect<ProcessedResults, FederationError>\n  readonly transformError: (error: FederationError, context: ErrorContext) => TransformedError\n}\n\n/**\n * Subgraph execution results\n * @category Error Handling\n */\nexport interface SubgraphResults {\n  readonly [subgraphId: string]: SubgraphResult\n}\n\n/**\n * Single subgraph execution result\n * @category Error Handling\n */\nexport interface SubgraphResult {\n  readonly subgraphId: string\n  readonly success: boolean\n  readonly data?: unknown\n  readonly error?: unknown\n}\n\n/**\n * Processed results after partial failure handling\n * @category Error Handling\n */\nexport interface ProcessedResults {\n  readonly data: unknown\n  readonly errors: ReadonlyArray<unknown>\n}\n\n/**\n * Error context for transformation\n * @category Error Handling\n */\nexport interface ErrorContext {\n  readonly subgraphId: string\n  readonly fieldPath: ReadonlyArray<string>\n  readonly operationType: 'query' | 'mutation' | 'subscription'\n  readonly timestamp: Date\n}\n\n/**\n * Transformed error for client consumption\n * @category Error Handling\n */\nexport interface TransformedError {\n  readonly message: string\n  readonly code: string\n  readonly path?: ReadonlyArray<string>\n  readonly extensions?: Record<string, unknown>\n}\n\n/**\n * FederationErrorBoundaries - Federation-aware error handling and circuit breakers\n *\n * Features:\n * - Circuit breakers per subgraph with state management\n * - Partial failure handling with fallback strategies\n * - Timeout management with configurable durations\n * - Error transformation and sanitization\n * - Metrics collection for monitoring\n */\nexport namespace FederationErrorBoundaries {\n  /**\n   * Create an error boundary with comprehensive fault tolerance\n   */\n  export const createBoundary = (config: ErrorBoundaryConfig): ErrorBoundary =>\n    pipe(\n      Effect.succeed(config),\n      Effect.map(conf => ({\n        wrapResolver: (subgraphId: string, resolver: GraphQLResolver) =>\n          createBoundedResolver(subgraphId, resolver, conf),\n\n        handlePartialFailure: (results: SubgraphResults) =>\n          processPartialResults(results, conf.partialFailureHandling),\n\n        transformError: (error: FederationError, context: ErrorContext) =>\n          transformFederationError(error, context, conf.errorTransformation),\n      }))\n    ).pipe(Effect.runSync)\n\n  /**\n   * Create a circuit breaker for a specific subgraph\n   */\n  export const withCircuitBreaker = (\n    subgraphId: string,\n    config: CircuitBreakerConfig\n  ): Effect.Effect<CircuitBreaker, CompositionError> =>\n    pipe(\n      Effect.succeed(config),\n      Effect.flatMap(validateCircuitBreakerConfig),\n      Effect.map(validConfig => createCircuitBreakerInstance(subgraphId, validConfig))\n    )\n\n  // === Internal Implementation ===\n\n  /**\n   * Create a bounded resolver with comprehensive error handling\n   */\n  const createBoundedResolver = (\n    subgraphId: string,\n    resolver: GraphQLResolver,\n    config: ErrorBoundaryConfig\n  ): BoundedResolver => {\n    const circuitBreaker = createCircuitBreakerInstance(subgraphId, config.circuitBreakerConfig)\n    const timeout = config.subgraphTimeouts[subgraphId] ?? Duration.seconds(10)\n\n    return (parent, args, context, info) => {\n      const startTime = Date.now()\n\n      return pipe(\n        Effect.tryPromise({\n          try: () => resolver(parent, args, context, info),\n          catch: error =>\n            ErrorFactory.federation('Resolver execution failed', subgraphId, 'execution', error),\n        }),\n        Effect.timeout(timeout),\n        Effect.catchTag('TimeoutException', () =>\n          Effect.fail(ErrorFactory.timeout(`Subgraph ${subgraphId} timed out`, timeout.toString()))\n        ),\n        circuitBreaker.protect,\n        Effect.tap(_result =>\n          Effect.sync(() => {\n            const duration = Date.now() - startTime\n            recordMetrics(subgraphId, { duration, success: true })\n          })\n        ),\n        Effect.catchAll(error => {\n          const duration = Date.now() - startTime\n          recordMetrics(subgraphId, { duration, success: false, error })\n\n          if (config.partialFailureHandling.allowPartialFailure === true) {\n            // Return null for failed field in partial failure mode\n            return Effect.succeed(null)\n          } else {\n            return Effect.fail(error)\n          }\n        }),\n        Effect.runPromise\n      )\n    }\n  }\n\n  /**\n   * Process partial failure results with fallback strategies\n   */\n  const processPartialResults = (\n    results: SubgraphResults,\n    config: PartialFailureConfig\n  ): Effect.Effect<ProcessedResults, FederationError> => {\n    const { successful, failed } = partitionResults(results)\n\n    if (failed.length === 0) {\n      return Effect.succeed({\n        data: mergeSuccessfulResults(successful),\n        errors: [],\n      })\n    }\n\n    if (config.allowPartialFailure === false) {\n      return Effect.fail(\n        ErrorFactory.federation('Subgraph failures not allowed', undefined, 'partial_failure', {\n          failedSubgraphs: failed.map(f => f.subgraphId),\n        })\n      )\n    }\n\n    // Check for critical subgraph failures\n    const criticalFailures = failed.filter(f =>\n      Boolean(config.criticalSubgraphs?.includes(f.subgraphId) ?? false)\n    )\n\n    if (criticalFailures.length > 0) {\n      return Effect.fail(\n        ErrorFactory.federation('Critical subgraph failure', undefined, 'critical_failure', {\n          failedSubgraphs: criticalFailures.map(f => f.subgraphId),\n        })\n      )\n    }\n\n    // Apply fallback values for failed subgraphs\n    const dataWithFallbacks = applyFallbackValues(successful, failed, config)\n\n    return Effect.succeed({\n      data: dataWithFallbacks,\n      errors: failed.map(f => transformSubgraphError(f.error)),\n    })\n  }\n\n  /**\n   * Partition results into successful and failed - optimized for performance\n   */\n  const partitionResults = (\n    results: SubgraphResults\n  ): {\n    readonly successful: readonly SubgraphResult[]\n    readonly failed: readonly SubgraphResult[]\n  } => {\n    const successful: SubgraphResult[] = []\n    const failed: SubgraphResult[] = []\n\n    // Use for...of for better performance than Object.values().forEach\n    for (const result of Object.values(results)) {\n      if (result.success) {\n        successful.push(result)\n      } else {\n        failed.push(result)\n      }\n    }\n\n    return { successful, failed }\n  }\n\n  /**\n   * Merge successful results into a single data object\n   */\n  const mergeSuccessfulResults = (results: readonly SubgraphResult[]): unknown => {\n    return results.reduce(\n      (merged, result) => ({\n        ...merged,\n        ...(typeof result.data === 'object' && result.data !== null ? result.data : {}),\n      }),\n      {}\n    )\n  }\n\n  /**\n   * Apply fallback values for failed subgraphs\n   */\n  const applyFallbackValues = (\n    successful: readonly SubgraphResult[],\n    failed: readonly SubgraphResult[],\n    config: PartialFailureConfig\n  ): unknown => {\n    let data = mergeSuccessfulResults(successful)\n\n    if (config.fallbackValues !== undefined) {\n      failed.forEach(failedResult => {\n        const fallback = config.fallbackValues?.[failedResult.subgraphId] ?? {}\n        data = {\n          ...(typeof data === 'object' && data !== null ? data : {}),\n          ...fallback,\n        }\n      })\n    }\n\n    return data\n  }\n\n  /**\n   * Transform subgraph error for client consumption\n   */\n  const transformSubgraphError = (error: unknown): unknown => {\n    const errorObj = error as {\n      message?: string\n      code?: string\n      extensions?: Record<string, unknown>\n    }\n    return {\n      message: errorObj.message ?? 'Subgraph execution failed',\n      extensions: {\n        code: errorObj.code ?? 'SUBGRAPH_ERROR',\n        timestamp: new Date().toISOString(),\n        ...errorObj.extensions,\n      },\n    }\n  }\n\n  /**\n   * Create circuit breaker instance with state management and performance optimizations\n   */\n  const createCircuitBreakerInstance = (\n    subgraphId: string,\n    config: CircuitBreakerConfig\n  ): CircuitBreaker => {\n    let state: CircuitBreakerState = 'closed'\n    let failureCount = 0\n    let lastFailureTime: number | null = null\n    let successCount = 0\n    let lastStateChange = Date.now()\n\n    // Pre-calculate timeout values for better performance\n    const resetTimeoutMs = Duration.toMillis(config.resetTimeout)\n    const halfOpenMaxCalls = config.halfOpenMaxCalls ?? 3\n\n    return {\n      protect: <A, E>(effect: Effect.Effect<A, E>): Effect.Effect<A, CircuitBreakerError | E> =>\n        pipe(\n          Effect.succeed(state),\n          Effect.flatMap((currentState): Effect.Effect<A, CircuitBreakerError | E> => {\n            switch (currentState) {\n              case 'open': {\n                // Use pre-calculated timeout for better performance\n                const canReset =\n                  lastFailureTime !== null && Date.now() - lastFailureTime >= resetTimeoutMs\n                return canReset\n                  ? pipe(\n                      Effect.sync(() => {\n                        state = 'half-open'\n                        successCount = 0\n                        lastStateChange = Date.now()\n                        console.log(`üîÑ Circuit breaker attempting reset for ${subgraphId}`)\n                      }),\n                      Effect.flatMap((): Effect.Effect<A, CircuitBreakerError | E> => effect)\n                    )\n                  : Effect.fail(\n                      ErrorFactory.circuitBreaker(`Circuit breaker open for ${subgraphId}`, 'open')\n                    )\n              }\n\n              case 'half-open':\n                return pipe(\n                  effect,\n                  Effect.tap(() =>\n                    Effect.sync(() => {\n                      successCount++\n                      if (successCount >= halfOpenMaxCalls) {\n                        state = 'closed'\n                        failureCount = 0\n                        successCount = 0\n                        lastStateChange = Date.now()\n                        console.log(`üîã Circuit breaker closed for ${subgraphId}`)\n                      }\n                    })\n                  ),\n                  Effect.catchAll(error => {\n                    state = 'open'\n                    lastFailureTime = Date.now()\n                    lastStateChange = Date.now()\n                    successCount = 0\n                    console.log(`‚ö° Circuit breaker opened for ${subgraphId}`)\n                    return Effect.fail(error)\n                  })\n                )\n\n              default:\n                return pipe(\n                  effect,\n                  Effect.tap(() =>\n                    Effect.sync(() => {\n                      // Reset failure count on success - only if needed\n                      if (failureCount > 0) {\n                        failureCount = 0\n                      }\n                    })\n                  ),\n                  Effect.catchAll(error => {\n                    failureCount++\n                    if (failureCount >= config.failureThreshold) {\n                      state = 'open'\n                      lastFailureTime = Date.now()\n                      lastStateChange = Date.now()\n                      console.log(\n                        `üö® Circuit breaker opened for ${subgraphId} (${failureCount} failures)`\n                      )\n                    }\n                    return Effect.fail(error)\n                  })\n                )\n            }\n          })\n        ),\n\n      getState: () => state,\n      getMetrics: (): CircuitBreakerMetrics => ({\n        failureCount,\n        lastFailureTime,\n        state,\n        lastStateChange,\n        successCount,\n        resetTimeoutMs,\n      }),\n    }\n  }\n\n  /**\n   * Optimized metrics recording with batching to reduce I/O overhead\n   */\n  let metricsBuffer: Array<{ subgraphId: string; metrics: unknown }> = []\n  let metricsFlushTimer: ReturnType<typeof setTimeout> | null = null\n\n  const flushMetrics = () => {\n    if (metricsBuffer.length === 0) return\n\n    // Batch process metrics\n    const batch = [...metricsBuffer]\n    metricsBuffer = []\n\n    // In production, this would batch write to monitoring system\n    console.log(`üìä Flushing ${batch.length} metrics entries`)\n\n    metricsFlushTimer = null\n  }\n\n  const scheduleMetricsFlush = () => {\n    if (metricsFlushTimer) return\n\n    metricsFlushTimer = setTimeout(flushMetrics, 1000) // 1 second batch window\n  }\n\n  /**\n   * Validate circuit breaker configuration\n   */\n  const validateCircuitBreakerConfig = (\n    config: CircuitBreakerConfig\n  ): Effect.Effect<CircuitBreakerConfig, CompositionError> =>\n    pipe(\n      Effect.succeed(config),\n      Effect.filterOrFail(\n        conf => conf.failureThreshold > 0,\n        () => ErrorFactory.composition('Failure threshold must be greater than 0')\n      ),\n      Effect.filterOrFail(\n        conf => Duration.toMillis(conf.resetTimeout) > 0,\n        () => ErrorFactory.composition('Reset timeout must be greater than 0')\n      )\n    )\n\n  /**\n   * Transform federation error for client consumption\n   */\n  const transformFederationError = (\n    error: FederationError,\n    context: ErrorContext,\n    config: ErrorTransformationConfig\n  ): TransformedError => {\n    const errorCode =\n      error._tag ??\n      ('code' in error && typeof error.code === 'string' ? error.code : 'FEDERATION_ERROR')\n    const baseError: TransformedError = {\n      message: config.sanitizeErrors === true ? 'Internal server error' : error.message,\n      code: errorCode,\n      path: context.fieldPath,\n      extensions: {\n        subgraphId: context.subgraphId,\n        operationType: context.operationType,\n        timestamp: context.timestamp.toISOString(),\n        ...(Boolean(config.includeStackTrace) && Boolean(error.cause)\n          ? {\n              stack: String(error.cause),\n            }\n          : {}),\n      },\n    }\n\n    if (config.customTransformer !== undefined) {\n      const transformedError = new Error(baseError.message)\n      transformedError.name = 'FederationError'\n\n      const result = config.customTransformer(transformedError)\n      return {\n        ...result,\n        message: result.message,\n        code: 'code' in result && typeof result.code === 'string' ? result.code : 'UNKNOWN_ERROR',\n      }\n    }\n\n    return baseError\n  }\n\n  /**\n   * Record metrics for monitoring with batching optimization\n   */\n  const recordMetrics = (\n    subgraphId: string,\n    metrics: {\n      readonly duration: number\n      readonly success: boolean\n      readonly error?: unknown\n    }\n  ): void => {\n    // Buffer metrics for batch processing to reduce I/O overhead\n    metricsBuffer.push({\n      subgraphId,\n      metrics: {\n        duration: metrics.duration,\n        success: metrics.success,\n        timestamp: Date.now(),\n        ...(metrics.error !== undefined &&\n          metrics.error !== null && {\n            errorType: metrics.error.constructor.name,\n          }),\n      },\n    })\n\n    scheduleMetricsFlush()\n\n    // For immediate debugging, still log individual critical failures\n    if (!metrics.success && metrics.duration > 1000) {\n      console.warn(`‚ö†Ô∏è Slow failure for ${subgraphId}: ${metrics.duration}ms`)\n    }\n  }\n\n  /**\n   * Default error boundary configuration\n   */\n  export const defaultConfig: ErrorBoundaryConfig = {\n    subgraphTimeouts: {},\n    circuitBreakerConfig: {\n      failureThreshold: 5,\n      resetTimeout: Duration.seconds(30),\n      halfOpenMaxCalls: 3,\n    },\n    partialFailureHandling: {\n      allowPartialFailure: true,\n      criticalSubgraphs: [],\n    },\n    errorTransformation: {\n      sanitizeErrors: false,\n      includeStackTrace: false,\n    },\n  }\n\n  /**\n   * Create error boundary with timeout configuration\n   */\n  export const withTimeouts = (\n    config: ErrorBoundaryConfig,\n    timeouts: Record<string, Duration.Duration>\n  ): ErrorBoundaryConfig => ({\n    ...config,\n    subgraphTimeouts: { ...config.subgraphTimeouts, ...timeouts },\n  })\n\n  /**\n   * Create error boundary with circuit breaker configuration\n   */\n  export const withCircuitBreakers = (\n    config: ErrorBoundaryConfig,\n    circuitBreakerConfig: CircuitBreakerConfig\n  ): ErrorBoundaryConfig => ({\n    ...config,\n    circuitBreakerConfig,\n  })\n\n  /**\n   * Create error boundary with partial failure handling\n   */\n  export const withPartialFailureHandling = (\n    config: ErrorBoundaryConfig,\n    partialFailureConfig: PartialFailureConfig\n  ): ErrorBoundaryConfig => ({\n    ...config,\n    partialFailureHandling: partialFailureConfig,\n  })\n}\n\n/**\n * Factory functions for common error boundary setups\n */\nexport const createStrictBoundary = (subgraphIds: ReadonlyArray<string>) =>\n  FederationErrorBoundaries.createBoundary(\n    FederationErrorBoundaries.withPartialFailureHandling(FederationErrorBoundaries.defaultConfig, {\n      allowPartialFailure: false,\n      criticalSubgraphs: [...subgraphIds],\n    })\n  )\n\nexport const createResilientBoundary = (\n  subgraphIds: ReadonlyArray<string>,\n  criticalSubgraphs: ReadonlyArray<string> = []\n) =>\n  FederationErrorBoundaries.createBoundary(\n    FederationErrorBoundaries.withPartialFailureHandling(FederationErrorBoundaries.defaultConfig, {\n      allowPartialFailure: true,\n      criticalSubgraphs: [...criticalSubgraphs],\n      fallbackValues: Object.fromEntries(subgraphIds.map(id => [id, {}])),\n    })\n  )\n\nexport const createProductionBoundary = (\n  subgraphTimeouts: Record<string, Duration.Duration>,\n  criticalSubgraphs: ReadonlyArray<string> = []\n) =>\n  FederationErrorBoundaries.createBoundary(\n    pipe(\n      FederationErrorBoundaries.defaultConfig,\n      config => FederationErrorBoundaries.withTimeouts(config, subgraphTimeouts),\n      config =>\n        FederationErrorBoundaries.withPartialFailureHandling(config, {\n          allowPartialFailure: true,\n          criticalSubgraphs: [...criticalSubgraphs],\n        }),\n      config => ({\n        ...config,\n        errorTransformation: {\n          sanitizeErrors: true,\n          includeStackTrace: false,\n        },\n      })\n    )\n  )\n","import type {\n  CompositionError,\n  DataLoaderConfig,\n  FederatedSchema,\n  MetricsConfig,\n  PerformanceConfig,\n  QueryPlanCacheConfig,\n  ValidationError,\n} from '@runtime/core'\nimport { ErrorFactory } from '@runtime/core'\nimport DataLoader from 'dataloader'\nimport { Duration, Effect, pipe } from 'effect'\nimport type { ExecutionResult } from 'graphql'\nimport { GraphQLError } from 'graphql'\n\n/**\n * Query plan representation for federation query execution\n *\n * Represents a complete execution plan for a federated GraphQL query,\n * including the sequence of operations across subgraphs and associated\n * performance metadata for optimization decisions.\n *\n * @example Query plan structure\n * ```typescript\n * const plan: QueryPlan = {\n *   id: 'query-hash-abc123',\n *   steps: [\n *     {\n *       subgraphId: 'users',\n *       operation: 'query Users($ids: [ID!]!) { users(ids: $ids) { id name email } }',\n *       dependencies: []\n *     },\n *     {\n *       subgraphId: 'orders',\n *       operation: 'query Orders($userIds: [ID!]!) { orders(userIds: $userIds) { id total } }',\n *       dependencies: ['users']\n *     }\n *   ],\n *   complexity: 25,\n *   estimatedCost: 150\n * }\n * ```\n *\n * @category Performance & Caching\n */\nexport interface QueryPlan {\n  readonly id: string\n  readonly steps: ReadonlyArray<QueryStep>\n  readonly complexity: number\n  readonly estimatedCost: number\n}\n\n/**\n * Query step representation\n * @category Performance Optimizations\n */\nexport interface QueryStep {\n  readonly subgraphId: string\n  readonly operation: string\n  readonly dependencies: ReadonlyArray<string>\n}\n\n/**\n * Cached query plan with metadata\n * @category Performance Optimizations\n */\nexport interface CachedQueryPlan {\n  readonly plan: QueryPlan\n  readonly createdAt: number\n  readonly accessCount: number\n  readonly lastAccessed: number\n}\n\n/**\n * Query plan cache interface with intelligent caching strategies\n *\n * High-performance cache implementation for federated query plans with LRU eviction,\n * pattern-based invalidation, and comprehensive statistics tracking.\n *\n * @example Basic cache usage\n * ```typescript\n * import { PerformanceOptimizations } from '@cqrs/federation'\n *\n * const cache = yield* PerformanceOptimizations.createQueryPlanCache({\n *   maxSize: 1000,\n *   ttl: Duration.hours(1)\n * })\n *\n * // Check cache for existing plan\n * const cachedPlan = yield* cache.get('query-hash-abc123')\n * if (Option.isSome(cachedPlan)) {\n *   return cachedPlan.value.plan\n * }\n *\n * // Store new plan\n * yield* cache.set('query-hash-abc123', queryPlan)\n * ```\n *\n * @example Pattern-based invalidation\n * ```typescript\n * // Invalidate all plans involving specific subgraph\n * yield* cache.invalidate('users-*')\n *\n * // Invalidate all cached plans\n * yield* cache.invalidate()\n * ```\n *\n * @category Performance & Caching\n */\nexport interface QueryPlanCache {\n  readonly get: (queryHash: string) => Effect.Effect<CachedQueryPlan | undefined, never>\n  readonly set: (queryHash: string, plan: QueryPlan) => Effect.Effect<void, never>\n  readonly invalidate: (pattern?: string) => Effect.Effect<void, never>\n  readonly getStats: () => Effect.Effect<CacheStats, never>\n}\n\n/**\n * Cache statistics\n * @category Performance Optimizations\n */\nexport interface CacheStats {\n  readonly size: number\n  readonly hitRate: number\n  readonly missRate: number\n  readonly evictionCount: number\n}\n\n/**\n * Federated DataLoader interface for efficient batch loading across subgraphs\n *\n * Provides intelligent batching and caching capabilities for data fetching\n * across multiple federated subgraphs, with per-subgraph DataLoader instances\n * and comprehensive performance monitoring.\n *\n * @example Basic DataLoader usage\n * ```typescript\n * import { PerformanceOptimizations } from '@cqrs/federation'\n *\n * const dataLoader = yield* PerformanceOptimizations.createFederatedDataLoader({\n *   maxBatchSize: 100,\n *   batchWindowMs: 10,\n *   enableBatchLogging: true\n * })\n *\n * // Get loader for specific subgraph\n * const userLoader = yield* dataLoader.getLoader('users', async (userIds) => {\n *   return await fetchUsersByIds(userIds)\n * })\n *\n * // Load data with automatic batching\n * const user = yield* Effect.fromPromise(() => userLoader.load('user-123'))\n * ```\n *\n * @example Advanced batching with custom key function\n * ```typescript\n * const productLoader = yield* dataLoader.getLoader(\n *   'products',\n *   async (keys) => fetchProductsByKeys(keys),\n *   {\n *     cacheKeyFn: (key) => `product:${key.id}:${key.version}`,\n *     maxBatchSize: 50\n *   }\n * )\n * ```\n *\n * @category Performance & Caching\n */\nexport interface FederatedDataLoader {\n  readonly getLoader: <K, V>(\n    subgraphId: string,\n    batchLoadFn: (keys: readonly K[]) => Promise<readonly V[]>\n  ) => Effect.Effect<DataLoader<K, V>, never>\n  readonly clearAll: () => Effect.Effect<void, never>\n  readonly getStats: () => Effect.Effect<DataLoaderStats, never>\n}\n\n/**\n * DataLoader statistics\n * @category Performance Optimizations\n */\nexport interface DataLoaderStats {\n  readonly [subgraphId: string]: {\n    readonly loadCount: number\n    readonly batchCount: number\n    readonly averageBatchSize: number\n    readonly cacheHitRate: number\n  }\n}\n\n/**\n * Metrics collector interface\n * @category Performance Optimizations\n */\nexport interface MetricsCollector {\n  readonly recordExecution: (metrics: ExecutionMetrics) => Effect.Effect<void, never>\n  readonly recordCacheOperation: (operation: CacheOperation) => Effect.Effect<void, never>\n  readonly getMetrics: () => Effect.Effect<PerformanceMetrics, never>\n}\n\n/**\n * Execution metrics\n * @category Performance Optimizations\n */\nexport interface ExecutionMetrics {\n  readonly queryHash: string\n  readonly duration: number\n  readonly success: boolean\n  readonly subgraphCalls: ReadonlyArray<SubgraphCall>\n  readonly cacheHit?: boolean\n}\n\n/**\n * Subgraph call metrics\n * @category Performance Optimizations\n */\nexport interface SubgraphCall {\n  readonly subgraphId: string\n  readonly duration: number\n  readonly success: boolean\n  readonly batchSize?: number\n}\n\n/**\n * Cache operation metrics\n * @category Performance Optimizations\n */\nexport interface CacheOperation {\n  readonly type: 'hit' | 'miss' | 'set' | 'evict'\n  readonly key: string\n  readonly duration?: number\n}\n\n/**\n * Performance metrics summary\n * @category Performance Optimizations\n */\nexport interface PerformanceMetrics {\n  readonly executionMetrics: {\n    readonly totalExecutions: number\n    readonly averageDuration: number\n    readonly successRate: number\n  }\n  readonly cacheMetrics: CacheStats\n  readonly dataLoaderMetrics: DataLoaderStats\n}\n\n/**\n * Optimized executor interface\n */\nexport interface OptimizedExecutor {\n  readonly execute: (\n    query: string,\n    variables: Record<string, unknown>,\n    context: ExecutionContext\n  ) => Effect.Effect<ExecutionResult, ExecutionError>\n}\n\n/**\n * Execution context\n * @category Performance Optimizations\n */\nexport interface ExecutionContext {\n  readonly [key: string]: unknown\n  readonly dataLoader?: FederatedDataLoader\n}\n\n/**\n * Execution error\n * @category Error Handling\n */\nexport interface ExecutionError extends Error {\n  readonly _tag: 'ExecutionError'\n  readonly name: 'ExecutionError'\n  readonly message: string\n  readonly cause?: unknown\n}\n\n/**\n * # PerformanceOptimizations\n *\n * Comprehensive performance optimization suite for Apollo Federation 2.x with Effect-TS,\n * featuring intelligent query plan caching, DataLoader batching, and real-time performance monitoring.\n *\n * ## üöÄ Key Features\n * - **‚ö° Query Plan Caching**: LRU cache with intelligent eviction strategies\n * - **üì¶ DataLoader Batching**: Automatic request batching per subgraph\n * - **üìä Performance Metrics**: Real-time monitoring and analytics\n * - **üî• Cache Warming**: Preload frequently accessed queries\n * - **‚öôÔ∏è Execution Optimization**: Parallel execution with circuit breakers\n * - **üéØ Smart Eviction**: Context-aware cache invalidation\n *\n * ## üìö Usage Examples\n *\n * ### Basic Performance Setup\n * ```typescript\n * import { PerformanceOptimizations } from '@cqrs/federation'\n * import { Effect } from 'effect'\n *\n * // Create optimized executor\n * const executor = yield* PerformanceOptimizations.createOptimizedExecutor(\n *   schema,\n *   {\n *     queryPlanCache: {\n *       maxSize: 1000,\n *       ttl: Duration.minutes(15),\n *       evictionStrategy: 'lru-with-priority'\n *     },\n *     dataLoader: {\n *       batchSize: 50,\n *       maxBatchDelay: Duration.milliseconds(10),\n *       cacheKeyFn: (key) => `subgraph:${key.subgraphId}:${key.id}`\n *     },\n *     metrics: {\n *       enabled: true,\n *       bufferSize: 1000,\n *       flushInterval: Duration.seconds(10)\n *     }\n *   }\n * )\n * ```\n *\n * ### Advanced Caching Configuration\n * ```typescript\n * const queryCache = yield* PerformanceOptimizations.createQueryPlanCache({\n *   maxSize: 5000,\n *   ttl: Duration.minutes(30),\n *   evictionStrategy: 'lru-with-priority',\n *   warmupQueries: [\n *     'query GetPopularProducts { ... }',\n *     'query GetUserProfile { ... }'\n *   ],\n *   priorityFn: (query) => query.includes('popular') ? 10 : 1\n * })\n *\n * // Warm the cache\n * yield* queryCache.warmup()\n * ```\n *\n * ### DataLoader with Custom Batching\n * ```typescript\n * const dataLoader = yield* PerformanceOptimizations.createFederatedDataLoader({\n *   batchSize: 100,\n *   maxBatchDelay: Duration.milliseconds(5),\n *   cacheKeyFn: (key) => `${key.type}:${key.id}`,\n *   batchScheduleFn: 'immediate' // or 'nextTick' | 'timeout'\n * })\n *\n * // Use with subgraph-specific loaders\n * const userLoader = yield* dataLoader.getLoader(\n *   'users-service',\n *   (userIds) => fetchUsersBatch(userIds)\n * )\n *\n * const user = yield* userLoader.load('user-123')\n * ```\n *\n * ## üìà Performance Monitoring\n *\n * ```typescript\n * const metrics = yield* PerformanceOptimizations.createMetricsCollector({\n *   bufferSize: 1000,\n *   flushInterval: Duration.seconds(5),\n *   aggregationWindow: Duration.minutes(1)\n * })\n *\n * // Monitor execution metrics\n * yield* metrics.recordExecution({\n *   queryHash: 'abc123',\n *   duration: 45,\n *   success: true,\n *   subgraphCalls: [\n *     { subgraphId: 'users', duration: 20, success: true, batchSize: 5 },\n *     { subgraphId: 'orders', duration: 25, success: true, batchSize: 3 }\n *   ],\n *   cacheHit: true\n * })\n *\n * // Get performance insights\n * const performanceData = yield* metrics.getMetrics()\n * console.log(`Cache hit rate: ${performanceData.cacheMetrics.hitRate * 100}%`)\n * console.log(`Avg response time: ${performanceData.executionMetrics.averageDuration}ms`)\n * ```\n *\n * @namespace PerformanceOptimizations\n * @category Performance & Caching\n * @see {@link https://www.apollographql.com/docs/federation/performance/ | Federation Performance Guide}\n * @see {@link https://github.com/graphql/dataloader | DataLoader Documentation}\n */\nexport namespace PerformanceOptimizations {\n  /**\n   * Create an optimized executor with comprehensive performance enhancements\n   */\n  export const createOptimizedExecutor = (\n    schema: FederatedSchema,\n    config: PerformanceConfig\n  ): Effect.Effect<OptimizedExecutor, CompositionError> =>\n    pipe(\n      Effect.succeed(config),\n      Effect.flatMap(config =>\n        validatePerformanceConfig(config).pipe(\n          Effect.mapError(\n            (error): CompositionError =>\n              ErrorFactory.composition(\n                `Performance configuration invalid: ${error.message}`,\n                schema.metadata.subgraphCount.toString(),\n                'performance'\n              )\n          )\n        )\n      ),\n      Effect.flatMap(validConfig =>\n        Effect.all({\n          queryPlanCache: createQueryPlanCache(validConfig.queryPlanCache).pipe(\n            Effect.mapError(\n              (error): CompositionError =>\n                ErrorFactory.composition(\n                  `Query plan cache creation failed: ${error.message}`,\n                  undefined,\n                  'cache'\n                )\n            )\n          ),\n          dataLoader: createFederatedDataLoader(validConfig.dataLoaderConfig).pipe(\n            Effect.mapError(\n              (error): CompositionError =>\n                ErrorFactory.composition(\n                  `DataLoader creation failed: ${error.message}`,\n                  undefined,\n                  'dataloader'\n                )\n            )\n          ),\n          metricsCollector: createMetricsCollector(validConfig.metricsCollection).pipe(\n            Effect.mapError(\n              (error): CompositionError =>\n                ErrorFactory.composition(\n                  `Metrics collector creation failed: ${error.message}`,\n                  undefined,\n                  'metrics'\n                )\n            )\n          ),\n        })\n      ),\n      Effect.map(({ queryPlanCache, dataLoader, metricsCollector }) => ({\n        execute: (query, variables, context) =>\n          executeOptimizedQuery(schema, query, variables, context, {\n            queryPlanCache,\n            dataLoader,\n            metricsCollector,\n          }),\n      }))\n    )\n\n  /**\n   * Create query plan cache with LRU eviction\n   */\n  export const createQueryPlanCache = (\n    config: QueryPlanCacheConfig\n  ): Effect.Effect<QueryPlanCache, ValidationError> => {\n    const cache = new Map<string, CachedQueryPlan>()\n    const stats = {\n      hits: 0,\n      misses: 0,\n      evictions: 0,\n    }\n\n    return Effect.succeed({\n      get: (queryHash: string) =>\n        Effect.sync(() => {\n          const cached = cache.get(queryHash)\n          if (cached) {\n            stats.hits++\n            // Update access time and count\n            const updated = {\n              ...cached,\n              accessCount: cached.accessCount + 1,\n              lastAccessed: Date.now(),\n            }\n            cache.set(queryHash, updated)\n            return updated\n          } else {\n            stats.misses++\n            return undefined\n          }\n        }),\n\n      set: (queryHash: string, plan: QueryPlan) =>\n        Effect.sync(() => {\n          // LRU eviction if cache is full - evict multiple entries for better amortization\n          if (cache.size >= config.maxSize) {\n            const entriesToEvict = Math.max(1, Math.floor(config.maxSize * 0.1)) // Evict 10%\n            const sortedEntries = Array.from(cache.entries())\n              .sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed)\n              .slice(0, entriesToEvict)\n\n            for (const [key] of sortedEntries) {\n              cache.delete(key)\n              stats.evictions++\n            }\n          }\n\n          cache.set(queryHash, {\n            plan,\n            createdAt: Date.now(),\n            accessCount: 1,\n            lastAccessed: Date.now(),\n          })\n        }),\n\n      invalidate: (pattern?: string) =>\n        Effect.sync(() => {\n          if (pattern !== undefined) {\n            for (const [key] of cache) {\n              if (key.includes(pattern)) {\n                cache.delete(key)\n              }\n            }\n          } else {\n            cache.clear()\n          }\n        }),\n\n      getStats: () =>\n        Effect.succeed({\n          size: cache.size,\n          hitRate: stats.hits / (stats.hits + stats.misses) || 0,\n          missRate: stats.misses / (stats.hits + stats.misses) || 0,\n          evictionCount: stats.evictions,\n        }),\n    })\n  }\n\n  /**\n   * Create federated DataLoader with per-subgraph batching\n   */\n  export const createFederatedDataLoader = (\n    config: DataLoaderConfig\n  ): Effect.Effect<FederatedDataLoader, ValidationError> => {\n    const loaders = new Map<string, DataLoader<unknown, unknown>>()\n    const stats = new Map<\n      string,\n      {\n        readonly loadCount: number\n        readonly batchCount: number\n        readonly totalBatchSize: number\n        readonly cacheHits: number\n        readonly cacheMisses: number\n      }\n    >()\n\n    return Effect.succeed({\n      getLoader: <K, V>(\n        subgraphId: string,\n        batchLoadFn: (keys: readonly K[]) => Promise<readonly V[]>\n      ) =>\n        Effect.sync(() => {\n          const loaderKey = `${subgraphId}:${batchLoadFn.name || 'default'}`\n\n          if (!loaders.has(loaderKey)) {\n            // Initialize stats for this subgraph\n            if (!stats.has(subgraphId)) {\n              stats.set(subgraphId, {\n                loadCount: 0,\n                batchCount: 0,\n                totalBatchSize: 0,\n                cacheHits: 0,\n                cacheMisses: 0,\n              })\n            }\n\n            const subgraphStats = stats.get(subgraphId)!\n\n            const instrumentedBatchFn = async (keys: readonly K[]): Promise<readonly V[]> => {\n              const currentStats = stats.get(subgraphId) ?? {\n                loadCount: 0,\n                batchCount: 0,\n                totalBatchSize: 0,\n                cacheHits: 0,\n                cacheMisses: 0,\n              }\n              stats.set(subgraphId, {\n                ...currentStats,\n                batchCount: currentStats.batchCount + 1,\n                totalBatchSize: currentStats.totalBatchSize + keys.length,\n              })\n\n              if (config.enableBatchLogging !== false) {\n                console.log(`üîÑ DataLoader batch for ${subgraphId}: ${keys.length} keys`)\n              }\n\n              const startTime = Date.now()\n              try {\n                const results = await batchLoadFn(keys)\n                const duration = Date.now() - startTime\n\n                if (config.enableBatchLogging !== false) {\n                  console.log(`‚úÖ DataLoader batch completed for ${subgraphId} in ${duration}ms`)\n                }\n                return results\n              } catch (error) {\n                const duration = Date.now() - startTime\n                console.error(\n                  `‚ùå DataLoader batch failed for ${subgraphId} after ${duration}ms:`,\n                  error\n                )\n                throw error\n              }\n            }\n\n            const dataLoaderOptions = {\n              maxBatchSize: config.maxBatchSize,\n              ...(config.cacheKeyFn && { cacheKeyFn: config.cacheKeyFn }),\n              ...(config.batchWindowMs !== undefined && {\n                batchScheduleFn: (callback: () => void) =>\n                  setTimeout(callback, config.batchWindowMs),\n              }),\n              cacheMap: (() => {\n                const map = new Map()\n                return {\n                  get: (key: string) => {\n                    const result = map.get(key)\n                    if (result !== undefined) {\n                      stats.set(subgraphId, {\n                        ...subgraphStats,\n                        cacheHits: subgraphStats.cacheHits + 1,\n                      })\n                    } else {\n                      stats.set(subgraphId, {\n                        ...subgraphStats,\n                        cacheMisses: subgraphStats.cacheMisses + 1,\n                      })\n                    }\n                    return result\n                  },\n                  set: (key: string, value: Promise<unknown>) => {\n                    map.set(key, value)\n                    return map\n                  },\n                  delete: (key: string) => map.delete(key),\n                  clear: () => map.clear(),\n                }\n              })(),\n            }\n\n            loaders.set(loaderKey, new DataLoader(instrumentedBatchFn, dataLoaderOptions))\n          }\n\n          return loaders.get(loaderKey) as DataLoader<K, V>\n        }),\n\n      clearAll: () =>\n        Effect.sync(() => {\n          for (const [, loader] of loaders) {\n            loader.clearAll()\n          }\n          loaders.clear()\n          stats.clear()\n        }),\n\n      getStats: () =>\n        Effect.succeed(\n          Object.fromEntries(\n            Array.from(stats.entries()).map(([subgraphId, stat]) => [\n              subgraphId,\n              {\n                loadCount: stat.loadCount,\n                batchCount: stat.batchCount,\n                averageBatchSize: stat.batchCount > 0 ? stat.totalBatchSize / stat.batchCount : 0,\n                cacheHitRate:\n                  stat.cacheHits + stat.cacheMisses > 0\n                    ? stat.cacheHits / (stat.cacheHits + stat.cacheMisses)\n                    : 0,\n              },\n            ])\n          )\n        ),\n    })\n  }\n\n  /**\n   * Create metrics collector for performance monitoring\n   */\n  export const createMetricsCollector = (\n    config: MetricsConfig\n  ): Effect.Effect<MetricsCollector, ValidationError> => {\n    const executionMetrics: ExecutionMetrics[] = []\n    const cacheOperations: CacheOperation[] = []\n\n    return Effect.succeed({\n      recordExecution: (metrics: ExecutionMetrics) =>\n        Effect.sync(() => {\n          if (config.enabled && config.collectExecutionMetrics !== false) {\n            executionMetrics.push({\n              ...metrics,\n              // Add timestamp\n              timestamp: Date.now(),\n            } as ExecutionMetrics & { readonly timestamp: number })\n\n            // Keep only recent metrics with efficient cleanup\n            const maxMetrics = config.maxExecutionMetrics ?? 1000\n            if (executionMetrics.length > maxMetrics) {\n              // Remove oldest 20% for better performance than shifting one by one\n              executionMetrics.splice(0, Math.floor(maxMetrics * 0.2))\n            }\n          }\n        }),\n\n      recordCacheOperation: (operation: CacheOperation) =>\n        Effect.sync(() => {\n          if (config.enabled && config.collectCacheMetrics !== false) {\n            cacheOperations.push({\n              ...operation,\n              timestamp: Date.now(),\n            } as CacheOperation & { readonly timestamp: number })\n\n            // Keep only recent operations with efficient cleanup\n            const maxOperations = config.maxCacheOperations ?? 1000\n            if (cacheOperations.length > maxOperations) {\n              // Remove oldest 20% for better performance than shifting one by one\n              cacheOperations.splice(0, Math.floor(maxOperations * 0.2))\n            }\n          }\n        }),\n\n      getMetrics: () =>\n        Effect.succeed({\n          executionMetrics: {\n            totalExecutions: executionMetrics.length,\n            averageDuration:\n              executionMetrics.reduce((sum, m) => sum + m.duration, 0) / executionMetrics.length ||\n              0,\n            successRate:\n              executionMetrics.filter(m => m.success).length / executionMetrics.length || 0,\n          },\n          cacheMetrics: {\n            size: 0, // Would be populated from actual cache\n            hitRate:\n              cacheOperations.filter(op => op.type === 'hit').length / cacheOperations.length || 0,\n            missRate:\n              cacheOperations.filter(op => op.type === 'miss').length / cacheOperations.length || 0,\n            evictionCount: cacheOperations.filter(op => op.type === 'evict').length,\n          },\n          dataLoaderMetrics: {}, // Would be populated from DataLoader stats\n        }),\n    })\n  }\n\n  // === Internal Implementation ===\n\n  /**\n   * Execute optimized query with caching and batching\n   */\n  const executeOptimizedQuery = (\n    schema: FederatedSchema,\n    query: string,\n    variables: Record<string, unknown>,\n    context: ExecutionContext,\n    optimizations: {\n      readonly queryPlanCache: QueryPlanCache\n      readonly dataLoader: FederatedDataLoader\n      readonly metricsCollector: MetricsCollector\n    }\n  ): Effect.Effect<ExecutionResult, ExecutionError> => {\n    const startTime = Date.now()\n    const queryHash = createQueryHash(query, variables)\n\n    return pipe(\n      // Try to get cached query plan\n      optimizations.queryPlanCache.get(queryHash),\n      Effect.flatMap(cachedPlan => {\n        if (cachedPlan) {\n          return pipe(\n            optimizations.metricsCollector.recordCacheOperation({\n              type: 'hit',\n              key: queryHash,\n            }),\n            Effect.as(cachedPlan.plan)\n          )\n        } else {\n          return pipe(\n            optimizations.metricsCollector.recordCacheOperation({\n              type: 'miss',\n              key: queryHash,\n            }),\n            Effect.flatMap(() => createQueryPlan(schema, query)),\n            Effect.tap(plan => optimizations.queryPlanCache.set(queryHash, plan))\n          )\n        }\n      }),\n      Effect.flatMap(queryPlan =>\n        executeQueryPlan(queryPlan, variables, {\n          ...context,\n          dataLoader: optimizations.dataLoader,\n        })\n      ),\n      Effect.tap(result => {\n        const duration = Date.now() - startTime\n        return optimizations.metricsCollector.recordExecution({\n          queryHash,\n          duration,\n          success: (result.errors?.length ?? 0) === 0,\n          subgraphCalls:\n            (result.extensions?.['subgraphCalls'] as ReadonlyArray<SubgraphCall>) ?? [],\n        })\n      }),\n      Effect.catchAll(error =>\n        Effect.succeed({\n          data: null,\n          errors: [\n            new GraphQLError(\n              error.message || 'Execution failed',\n              undefined,\n              undefined,\n              undefined,\n              undefined,\n              error,\n              {\n                code: 'EXECUTION_ERROR',\n                timestamp: new Date().toISOString(),\n              }\n            ),\n          ],\n        } as ExecutionResult)\n      )\n    )\n  }\n\n  /**\n   * Create query hash for caching using FNV-1a algorithm for better distribution\n   */\n  const createQueryHash = (query: string, variables: Record<string, unknown>): string => {\n    // Use FNV-1a hash for better distribution and fewer collisions\n    const content = query + JSON.stringify(variables, Object.keys(variables).sort())\n    let hash = 2166136261 // FNV offset basis\n\n    for (let i = 0; i < content.length; i++) {\n      hash ^= content.charCodeAt(i)\n      hash = Math.imul(hash, 16777619) // FNV prime\n    }\n\n    return (hash >>> 0).toString(16) // Convert to unsigned 32-bit\n  }\n\n  /**\n   * Create query plan from GraphQL query\n   */\n  const createQueryPlan = (\n    _schema: FederatedSchema,\n    query: string\n  ): Effect.Effect<QueryPlan, ExecutionError> =>\n    pipe(\n      Effect.tryPromise({\n        try: async () => {\n          // In a real implementation, this would analyze the query\n          // and create an optimized execution plan\n          console.log(`üìã Creating query plan for query`)\n\n          return {\n            id: createQueryHash(query, {}),\n            steps: [\n              {\n                subgraphId: 'default',\n                operation: query,\n                dependencies: [],\n              },\n            ],\n            complexity: 1,\n            estimatedCost: 10,\n          }\n        },\n        catch: error => {\n          const execError: ExecutionError = {\n            _tag: 'ExecutionError',\n            name: 'ExecutionError',\n            message: 'Failed to create query plan',\n            cause: error,\n          }\n          return execError\n        },\n      })\n    )\n\n  /**\n   * Execute query plan with DataLoader optimization\n   */\n  const executeQueryPlan = (\n    plan: QueryPlan,\n    _variables: Record<string, unknown>,\n    _context: ExecutionContext\n  ): Effect.Effect<ExecutionResult, ExecutionError> =>\n    pipe(\n      Effect.tryPromise({\n        try: async () => {\n          console.log(`‚ö° Executing query plan with ${plan.steps.length} steps`)\n\n          // Mock execution result\n          return {\n            data: { mock: 'This is a mock result for demonstration' },\n            extensions: {\n              subgraphCalls: plan.steps.map(step => ({\n                subgraphId: step.subgraphId,\n                duration: Math.random() * 100,\n                success: true,\n              })),\n            },\n          }\n        },\n        catch: error => {\n          const execError: ExecutionError = {\n            _tag: 'ExecutionError',\n            name: 'ExecutionError',\n            message: 'Query execution failed',\n            cause: error,\n          }\n          return execError\n        },\n      })\n    )\n\n  /**\n   * Validate performance configuration\n   */\n  const validatePerformanceConfig = (\n    config: PerformanceConfig\n  ): Effect.Effect<PerformanceConfig, ValidationError> =>\n    pipe(\n      Effect.succeed(config),\n      Effect.filterOrFail(\n        conf => conf.queryPlanCache.maxSize > 0,\n        () => ErrorFactory.validation('Query plan cache max size must be greater than 0', 'maxSize')\n      ),\n      Effect.filterOrFail(\n        conf => conf.dataLoaderConfig.maxBatchSize > 0,\n        () =>\n          ErrorFactory.validation(\n            'DataLoader max batch size must be greater than 0',\n            'maxBatchSize'\n          )\n      )\n    )\n\n  /**\n   * Default performance configuration\n   */\n  export const defaultConfig: PerformanceConfig = {\n    queryPlanCache: {\n      maxSize: 1000,\n      ttl: Duration.minutes(30),\n    },\n    dataLoaderConfig: {\n      maxBatchSize: 100,\n      batchWindowMs: 10,\n    },\n    metricsCollection: {\n      enabled: true,\n      collectExecutionMetrics: true,\n      collectCacheMetrics: true,\n    },\n  }\n\n  /**\n   * High-performance configuration for production\n   */\n  export const productionConfig: PerformanceConfig = {\n    queryPlanCache: {\n      maxSize: 10000,\n      ttl: Duration.hours(1),\n    },\n    dataLoaderConfig: {\n      maxBatchSize: 1000,\n      batchWindowMs: 5,\n    },\n    metricsCollection: {\n      enabled: true,\n      collectExecutionMetrics: true,\n      collectCacheMetrics: true,\n    },\n  }\n\n  /**\n   * Development configuration with detailed logging\n   */\n  export const developmentConfig: PerformanceConfig = {\n    queryPlanCache: {\n      maxSize: 100,\n      ttl: Duration.minutes(5),\n    },\n    dataLoaderConfig: {\n      maxBatchSize: 10,\n      batchWindowMs: 50,\n    },\n    metricsCollection: {\n      enabled: true,\n      collectExecutionMetrics: true,\n      collectCacheMetrics: true,\n    },\n  }\n}\n\n/**\n * Factory functions for common performance setups\n */\nexport const createBasicOptimizedExecutor = (schema: FederatedSchema) =>\n  PerformanceOptimizations.createOptimizedExecutor(schema, PerformanceOptimizations.defaultConfig)\n\nexport const createProductionOptimizedExecutor = (schema: FederatedSchema) =>\n  PerformanceOptimizations.createOptimizedExecutor(\n    schema,\n    PerformanceOptimizations.productionConfig\n  )\n\nexport const createDevelopmentOptimizedExecutor = (schema: FederatedSchema) =>\n  PerformanceOptimizations.createOptimizedExecutor(\n    schema,\n    PerformanceOptimizations.developmentConfig\n  )\n"],"mappings":"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"}