{"version":3,"file":"runtime-CCTzkf8P.js","names":["error","evolutions: readonly SchemaEvolution[]","entities","language","nextContext: TypeConversionContext","filtered: Record<string, GraphQLOutputType>","isGraphQLOutputType","ast","title: string"],"sources":["../src/runtime/core/types/types.ts","../src/runtime/core/schema-first-patterns.ts","../src/runtime/effect/services/layers.ts","../src/runtime/schema/ast/ast.ts","../src/runtime/index.ts"],"sourcesContent":["import type * as Schema from 'effect/Schema'\nimport type { Duration, Effect } from 'effect'\nimport type { GraphQLResolveInfo, GraphQLSchema } from 'graphql'\nimport type {\n  BaseDomainError,\n  CircuitBreakerError,\n  CompositionError,\n  DiscoveryError,\n  EntityResolutionError,\n  FederationError,\n  FieldResolutionError,\n  HealthCheckError,\n  RegistrationError,\n  SchemaValidationError,\n  TimeoutError,\n  TypeConversionError,\n  ValidationError,\n} from '../errors/errors.js'\n\nexport type {\n  CircuitBreakerError,\n  CompositionError,\n  DiscoveryError,\n  EntityResolutionError,\n  FederationError,\n  FieldResolutionError,\n  HealthCheckError,\n  RegistrationError,\n  SchemaValidationError,\n  TimeoutError,\n  TypeConversionError,\n  ValidationError,\n}\n\n/**\n * Core federation entity definition with full Apollo Federation 2.x support\n *\n * Represents a GraphQL entity that can be federated across multiple subgraphs.\n * Entities are types that can be resolved from references and extended by other subgraphs.\n *\n * @template TSource - The source data type (e.g., from database or API)\n * @template TContext - The GraphQL execution context type (user, services, etc.)\n * @template TResult - The resolved entity type returned to clients\n * @template TReference - The reference type containing key fields for entity lookup\n *\n * @example\n * ```typescript\n * const userEntity: FederationEntity<DatabaseUser, AppContext, User, UserRef> = {\n *   typename: 'User',\n *   key: ['id'],\n *   schema: UserSchema,\n *   resolveReference: resolveUserFromReference,\n *   fields: {\n *     displayName: resolveUserDisplayName,\n *     avatar: resolveUserAvatar\n *   },\n *   directives: {\n *     email: [{ type: '@inaccessible' }]\n *   }\n * }\n * ```\n */\nexport interface FederationEntity<\n  TSource = Record<string, unknown>,\n  TContext = Record<string, unknown>,\n  TResult = Partial<TSource>,\n  TReference = Partial<TSource>,\n  TExtensions = Record<string, unknown>,\n> {\n  /** GraphQL type name - must match the type name in your schema */\n  readonly typename: string\n\n  /** Key field(s) that uniquely identify this entity across subgraphs */\n  readonly key: string | ReadonlyArray<string>\n\n  /** Effect Schema for runtime validation and type safety */\n  readonly schema: Schema.Schema<TSource, TResult>\n\n  /** Resolver function called when this entity is referenced by other subgraphs */\n  readonly resolveReference: EntityReferenceResolver<TResult, TContext, TReference>\n\n  /** Optional field resolvers for computed or federated fields */\n  readonly fields: FieldResolverMap<TResult, TContext> | undefined\n\n  /** Federation directives (@shareable, @inaccessible, @override, etc.) */\n  readonly directives: FederationDirectiveMap | undefined\n\n  /** Additional metadata for tooling and extensions */\n  readonly extensions: TExtensions | undefined\n}\n\n/**\n * Federation directive configuration\n */\nexport interface FederationDirectiveMap {\n  readonly [fieldName: string]: ReadonlyArray<FederationDirective>\n}\n\nexport interface FederationDirective {\n  readonly type:\n    | '@shareable'\n    | '@inaccessible'\n    | '@tag'\n    | '@override'\n    | '@external'\n    | '@provides'\n    | '@requires'\n  readonly args?: Record<string, unknown>\n}\n\n/**\n * Entity reference resolver with Effect-based error handling\n *\n * Called when Apollo Federation needs to resolve an entity from a reference.\n * The reference contains the key fields that identify the entity uniquely.\n *\n * @template TResult - The complete entity type to be returned\n * @template TContext - The GraphQL execution context type\n * @template TReference - The reference type containing key fields\n *\n * @param reference - Object containing key fields to identify the entity\n * @param context - GraphQL execution context with services, user info, etc.\n * @param info - GraphQL execution info with field selection and metadata\n *\n * @returns Effect resolving to the entity or EntityResolutionError\n *\n * @example\n * ```typescript\n * const resolveUser: EntityReferenceResolver<User, AppContext, UserRef> =\n *   (ref, ctx, info) => pipe(\n *     ctx.userService.findById(ref.id),\n *     Effect.mapError(err =>\n *       ErrorFactory.entityResolution(\n *         `User ${ref.id} not found`, 'User', ref.id, err\n *       )\n *     )\n *   )\n * ```\n */\nexport type EntityReferenceResolver<TResult, TContext, TReference> = (\n  reference: TReference,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => Effect.Effect<TResult, EntityResolutionError>\n\n/**\n * Field resolver map for federation entities\n */\nexport type FieldResolverMap<TResult, TContext> = {\n  readonly [K in keyof TResult]?: FieldResolver<TResult, TContext, TResult[K]>\n}\n\n/**\n * GraphQL field resolver with Effect-based error handling\n *\n * Resolves a specific field on a GraphQL type, with proper error handling\n * and context propagation using the Effect system.\n *\n * @template TSource - The parent object type containing this field\n * @template TContext - The GraphQL execution context type\n * @template TReturn - The return type of this field\n * @template TArgs - The arguments passed to this field\n *\n * @param parent - The parent object being resolved\n * @param args - Arguments passed to the GraphQL field\n * @param context - Execution context with services and user info\n * @param info - GraphQL execution info with field selection\n *\n * @returns Effect resolving to field value or FieldResolutionError\n *\n * @example\n * ```typescript\n * const resolveUserEmail: FieldResolver<User, AppContext, string> =\n *   (user, args, ctx, info) => pipe(\n *     ctx.authService.checkAccess(ctx.user, 'read:email'),\n *     Effect.flatMap(() => Effect.succeed(user.email)),\n *     Effect.mapError(err =>\n *       ErrorFactory.fieldResolution(\n *         'Insufficient permissions for email field', 'email', 'User', err\n *       )\n *     )\n *   )\n * ```\n */\nexport type FieldResolver<TSource, TContext, TReturn, TArgs = Record<string, unknown>> = (\n  parent: TSource,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => Effect.Effect<TReturn, FieldResolutionError>\n\n/**\n * Service definition for federation composition\n */\nexport interface ServiceDefinition {\n  readonly id: string\n  readonly url: string\n  readonly name?: string\n  readonly version?: string\n  readonly metadata?: Record<string, unknown>\n}\n\n/**\n * Federation composition configuration\n */\nexport interface FederationCompositionConfig {\n  readonly entities: ReadonlyArray<FederationEntity<unknown, unknown, unknown, unknown>>\n  readonly services: ReadonlyArray<ServiceDefinition>\n  readonly errorBoundaries: ErrorBoundaryConfig\n  readonly performance: PerformanceConfig\n}\n\n// Type helper to convert strongly typed entities to the config format\nexport const asUntypedEntity = <TSource, TContext, TResult, TReference>(\n  entity: FederationEntity<TSource, TContext, TResult, TReference>\n): FederationEntity<unknown, unknown, unknown, unknown> =>\n  entity as unknown as FederationEntity<unknown, unknown, unknown, unknown>\n\n/**\n * Error boundary configuration for circuit breakers and fault tolerance\n */\nexport interface ErrorBoundaryConfig {\n  readonly subgraphTimeouts: Record<string, Duration.Duration>\n  readonly circuitBreakerConfig: CircuitBreakerConfig\n  readonly partialFailureHandling: PartialFailureConfig\n  readonly errorTransformation: ErrorTransformationConfig\n}\n\nexport interface CircuitBreakerConfig {\n  readonly failureThreshold: number\n  readonly resetTimeout: Duration.Duration\n  readonly halfOpenMaxCalls?: number\n}\n\nexport interface PartialFailureConfig {\n  readonly allowPartialFailure: boolean\n  readonly criticalSubgraphs?: ReadonlyArray<string>\n  readonly fallbackValues?: Record<string, unknown>\n}\n\nexport interface ErrorTransformationConfig {\n  readonly sanitizeErrors?: boolean\n  readonly includeStackTrace?: boolean\n  readonly customTransformer?: <E extends Error>(error: E) => BaseDomainError\n}\n\n/**\n * Performance optimization configuration\n */\nexport interface PerformanceConfig {\n  readonly queryPlanCache: QueryPlanCacheConfig\n  readonly dataLoaderConfig: DataLoaderConfig\n  readonly metricsCollection: MetricsConfig\n}\n\nexport interface QueryPlanCacheConfig {\n  readonly maxSize: number\n  readonly ttl?: Duration.Duration\n}\n\nexport interface DataLoaderConfig {\n  readonly maxBatchSize: number\n  readonly batchWindowMs?: number\n  readonly cacheKeyFn?: (key: unknown) => string\n  readonly enableBatchLogging?: boolean\n  readonly maxCacheOperations?: number\n  readonly maxExecutionMetrics?: number\n}\n\nexport interface MetricsConfig {\n  readonly enabled: boolean\n  readonly collectExecutionMetrics?: boolean\n  readonly collectCacheMetrics?: boolean\n  readonly maxExecutionMetrics?: number\n  readonly maxCacheOperations?: number\n}\n\n/**\n * Schema composition result\n */\nexport interface FederatedSchema {\n  readonly schema: GraphQLSchema\n  readonly entities: ReadonlyArray<FederationEntity<unknown, unknown, unknown, unknown>>\n  readonly services: ReadonlyArray<ServiceDefinition>\n  readonly version: string\n  readonly metadata: SchemaMetadata\n}\n\nexport interface SchemaMetadata {\n  readonly createdAt: Date\n  readonly composedAt: Date\n  readonly federationVersion: string\n  readonly subgraphCount: number\n  readonly entityCount: number\n}\n\n/**\n * Hot reloadable schema for development\n */\nexport interface HotReloadableSchema {\n  readonly schema: FederatedSchema\n  readonly watcher: SchemaWatcher\n  readonly reload: () => Effect.Effect<FederatedSchema, CompositionError>\n}\n\nexport interface SchemaWatcher {\n  readonly on: (event: 'schemaChanged' | 'error', handler: (data: unknown) => void) => void\n  readonly off: (event: string, handler?: (data: unknown) => void) => void\n  readonly close: () => Effect.Effect<void, never>\n}\n\n/**\n * Subgraph registry for service discovery\n */\nexport interface SubgraphRegistry {\n  readonly register: (definition: ServiceDefinition) => Effect.Effect<void, RegistrationError>\n  readonly unregister: (serviceId: string) => Effect.Effect<void, RegistrationError>\n  readonly discover: () => Effect.Effect<ReadonlyArray<ServiceDefinition>, DiscoveryError>\n  readonly health: (serviceId: string) => Effect.Effect<HealthStatus, HealthCheckError>\n}\n\n/**\n * Health status of a federated subgraph service\n *\n * Represents the current operational status of a subgraph:\n * - `healthy`: Service responding normally with good performance\n * - `degraded`: Service responding but with poor performance or warnings\n * - `unhealthy`: Service not responding or returning errors\n *\n * @example\n * ```typescript\n * const health: HealthStatus = {\n *   status: 'healthy',\n *   serviceId: 'user-service',\n *   lastCheck: new Date(),\n *   metrics: {\n *     responseTimeMs: 42,\n *     statusCode: 200,\n *     memoryUsageMB: 256\n *   }\n * }\n * ```\n */\nexport interface HealthStatus {\n  /** Current health status of the service */\n  readonly status: 'healthy' | 'unhealthy' | 'degraded'\n\n  /** Unique identifier of the service */\n  readonly serviceId: string\n\n  /** Timestamp when health check was last performed */\n  readonly lastCheck?: Date\n\n  /** Optional metrics collected during health check */\n  readonly metrics?: Record<string, number>\n}\n\n/**\n * Circuit breaker state and operations\n *\n * Circuit breaker pattern implementation for fault tolerance:\n * - `closed`: Normal operation, all requests pass through\n * - `open`: Circuit is open, requests fail immediately (fail-fast)\n * - `half-open`: Testing phase, limited requests allowed to test recovery\n *\n * State transitions:\n * closed -> open: When failure threshold is exceeded\n * open -> half-open: After reset timeout expires\n * half-open -> closed: When test requests succeed\n * half-open -> open: When test requests fail\n *\n * @see {@link https://martinfowler.com/bliki/CircuitBreaker.html}\n */\nexport type CircuitBreakerState = 'closed' | 'open' | 'half-open'\n\nexport interface CircuitBreaker {\n  readonly protect: <A, E>(effect: Effect.Effect<A, E>) => Effect.Effect<A, E | CircuitBreakerError>\n  readonly getState: () => CircuitBreakerState\n  readonly getMetrics: () => CircuitBreakerMetrics\n}\n\nexport interface CircuitBreakerMetrics {\n  readonly failureCount: number\n  readonly lastFailureTime: number | null\n  readonly state: CircuitBreakerState\n  readonly lastStateChange?: number\n  readonly successCount?: number\n  readonly resetTimeoutMs?: number\n}\n\n/**\n * Error types for comprehensive error handling\n */\n\n/**\n * Schema first development types\n */\nexport interface SchemaImportResult {\n  readonly schema: Schema.Schema<unknown>\n  readonly directives: FederationDirectiveMap\n  readonly metadata: SchemaMetadata\n}\n\nexport interface SyncResult {\n  readonly changes: ReadonlyArray<SchemaChange>\n  readonly conflicts: ReadonlyArray<SchemaConflict>\n  readonly success: boolean\n}\n\nexport interface SchemaChange {\n  readonly type: 'add' | 'modify' | 'remove'\n  readonly path: string\n  readonly description: string\n}\n\nexport interface SchemaConflict {\n  readonly path: string\n  readonly local: unknown\n  readonly remote: unknown\n  readonly resolution?: 'local' | 'remote' | 'merge'\n}\n\n/**\n * Union type for all domain errors with exhaustive matching support\n *\n * This discriminated union enables exhaustive pattern matching in error handlers,\n * ensuring all error cases are handled at compile time.\n *\n * @example\n * ```typescript\n * const handleError = (error: DomainError): string =>\n *   Match.value(error).pipe(\n *     Match.tag('ValidationError', err => `Validation failed: ${err.message}`),\n *     Match.tag('FederationError', err => `Federation error: ${err.message}`),\n *     Match.tag('EntityResolutionError', err => `Entity not found: ${err.message}`),\n *     // ... handle all error types\n *     Match.exhaustive // Compile error if any error type is missing\n *   )\n * ```\n */\nexport type DomainError =\n  | EntityResolutionError\n  | FieldResolutionError\n  | ValidationError\n  | SchemaValidationError\n  | CompositionError\n  | RegistrationError\n  | DiscoveryError\n  | HealthCheckError\n  | CircuitBreakerError\n  | TimeoutError\n  | FederationError\n  | TypeConversionError\n\n/**\n * Type-safe branded types for domain concepts\n *\n * Branded types prevent accidental mixing of semantically different strings,\n * providing compile-time safety for domain-specific identifiers.\n *\n * @example\n * ```typescript\n * const serviceId: ServiceId = 'user-service' as ServiceId\n * const typeName: EntityTypename = 'User' as EntityTypename\n *\n * // This would cause a compile error:\n * // const wrong: ServiceId = typeName  // Type error!\n * ```\n */\nexport type ServiceId = string & { readonly __brand: 'ServiceId' }\nexport type EntityTypename = string & { readonly __brand: 'EntityTypename' }\nexport type FieldName = string & { readonly __brand: 'FieldName' }\nexport type QueryHash = string & { readonly __brand: 'QueryHash' }\n\n/**\n * Utility types for advanced type-level programming\n *\n * These utility types provide enhanced type safety and better developer\n * experience when working with complex federation configurations.\n */\n\n/**\n * Prettify type - flattens intersection types for better IDE display\n *\n * @example\n * ```typescript\n * type Complex = { a: string } & { b: number }  // Shows as intersection\n * type Clean = Prettify<Complex>                // Shows as { a: string; b: number }\n * ```\n */\nexport type Prettify<T> = { readonly [K in keyof T]: T[K] } & {}\n\n/**\n * Non-empty array type - ensures array has at least one element\n *\n * @example\n * ```typescript\n * const keys: NonEmptyArray<string> = ['id']           // ‚úì Valid\n * const empty: NonEmptyArray<string> = []              // ‚úó Type error\n * ```\n */\nexport type NonEmptyArray<T> = readonly [T, ...(readonly T[])]\n\n/**\n * Require at least one property from a set of optional properties\n *\n * @example\n * ```typescript\n * type Config = {\n *   name?: string\n *   url?: string\n *   port?: number\n * }\n *\n * type ValidConfig = RequireAtLeastOne<Config, 'url' | 'port'>\n * // Must have at least url or port, name is still optional\n * ```\n */\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n  {\n    readonly [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n  }[Keys]\n\n/**\n * Extract resolver function type from a field\n *\n * @example\n * ```typescript\n * type UserResolver = ExtractResolver<User, AppContext, 'displayName'>\n * // Results in: (parent: User, args: any, context: AppContext, info: GraphQLResolveInfo) => ...\n * ```\n */\nexport type ExtractResolver<TSource, TContext, TField extends keyof TSource> = FieldResolver<\n  TSource,\n  TContext,\n  TSource[TField]\n>\n\n/**\n * Create a type-safe resolver map from an entity type\n *\n * @example\n * ```typescript\n * type UserResolvers = SafeResolverMap<User, AppContext>\n * // Only allows resolvers for actual User fields with correct types\n * ```\n */\nexport type SafeResolverMap<TSource, TContext> = {\n  readonly [K in keyof TSource]?: ExtractResolver<TSource, TContext, K>\n}\n\n/**\n * Extract only the required keys from a type\n *\n * @example\n * ```typescript\n * type Required = RequiredKeys<{ id: string; name?: string; age?: number }>\n * // Results in: 'id'\n * ```\n */\nexport type RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K\n}[keyof T]\n\n/**\n * Extract only the optional keys from a type\n *\n * @example\n * ```typescript\n * type Optional = OptionalKeys<{ id: string; name?: string; age?: number }>\n * // Results in: 'name' | 'age'\n * ```\n */\nexport type OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never\n}[keyof T]\n\n/**\n * Make specific properties required while keeping others as-is\n *\n * @example\n * ```typescript\n * type User = { id?: string; name?: string; email?: string }\n * type UserWithId = MakeRequired<User, 'id'>  // { id: string; name?: string; email?: string }\n * ```\n */\nexport type MakeRequired<T, K extends keyof T> = T & Required<Pick<T, K>>\n\n/**\n * Deep readonly type that makes all nested properties readonly\n *\n * @example\n * ```typescript\n * type Config = { db: { host: string; port: number } }\n * type ReadonlyConfig = DeepReadonly<Config>  // { readonly db: { readonly host: string; readonly port: number } }\n * ```\n */\nexport type DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends (infer U)[]\n    ? ReadonlyArray<DeepReadonly<U>>\n    : T[P] extends object\n      ? DeepReadonly<T[P]>\n      : T[P]\n}\n","/**\n * Schema-First Development Patterns for Federation Framework\n *\n * Advanced schema-first development system that enables GraphQL schema evolution,\n * automated code generation, validation pipelines, and seamless integration with\n * Apollo Federation 2.x directives and ultra-strict entity builders.\n *\n * ## üéØ Schema-First Philosophy\n *\n * Schema-first development puts the GraphQL schema at the center of your development workflow:\n * - **Schema as Source of Truth**: GraphQL schema defines the contract between services\n * - **Code Generation**: Automatically generate TypeScript types, resolvers, and validators\n * - **Schema Evolution**: Manage schema changes with compatibility checking\n * - **Validation Pipelines**: Ensure schema compliance before deployment\n * - **Federation Integration**: Seamless integration with Apollo Federation directives\n *\n * ## üîÑ Development Lifecycle\n *\n * ```\n * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n * ‚îÇ    Draft     ‚îÇ -> ‚îÇ    Validated    ‚îÇ -> ‚îÇ    Composed      ‚îÇ -> ‚îÇ    Deployed     ‚îÇ\n * ‚îÇ              ‚îÇ    ‚îÇ                 ‚îÇ    ‚îÇ                  ‚îÇ    ‚îÇ                 ‚îÇ\n * ‚îÇ ‚Ä¢ GraphQL    ‚îÇ    ‚îÇ ‚Ä¢ Type Safe     ‚îÇ    ‚îÇ ‚Ä¢ Federation     ‚îÇ    ‚îÇ ‚Ä¢ Live Schema   ‚îÇ\n * ‚îÇ ‚Ä¢ Unverified ‚îÇ    ‚îÇ ‚Ä¢ Entity Built  ‚îÇ    ‚îÇ ‚Ä¢ Multi-Subgraph ‚îÇ    ‚îÇ ‚Ä¢ Versioned     ‚îÇ\n * ‚îÇ ‚Ä¢ Editable   ‚îÇ    ‚îÇ ‚Ä¢ Directive OK  ‚îÇ    ‚îÇ ‚Ä¢ Query Plans    ‚îÇ    ‚îÇ ‚Ä¢ Monitored     ‚îÇ\n * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n * ```\n *\n * ## üåü Key Features\n * - **Hot Schema Reloading**: Watch GraphQL files and automatically regenerate types\n * - **Schema Validation**: Comprehensive validation with Federation directive checking\n * - **Entity Code Generation**: Generate ultra-strict entity builders from GraphQL\n * - **Change Management**: Track schema changes and generate evolution strategies\n * - **Compatibility Checking**: Ensure compatibility across schema versions\n * - **Federation Directives**: Full support for @key, @shareable, @inaccessible, etc.\n * - **TypeScript Integration**: Generate type-safe resolvers and context types\n *\n * @example Basic schema-first workflow\n * ```typescript\n * import { SchemaFirstDevelopment } from '@cqrs/federation'\n * import { readFileSync } from 'fs'\n *\n * const schemaSDL = readFileSync('./user-schema.graphql', 'utf-8')\n *\n * const development = Effect.gen(function* () {\n *   const manager = yield* SchemaFirstDevelopment.create({\n *     schemaFiles: ['./user-schema.graphql'],\n *     outputDir: './generated',\n *     federationVersion: '2.3',\n *     validation: 'ultra-strict'\n *   })\n *\n *   // Step 1: Import and validate schema\n *   const draft = yield* manager.importSchema(schemaSDL, '1.0.0')\n *\n *   // Step 2: Generate entities and validate\n *   const validated = yield* manager.validateAndGenerate(draft)\n *\n *   // Step 3: Compose federated schema\n *   const composed = yield* manager.composeSchema(validated)\n *\n *   // Step 4: Deploy to federation gateway\n *   const deployed = yield* manager.deploySchema(composed)\n *\n *   return deployed\n * })\n * ```\n *\n * @example Advanced schema evolution\n * ```typescript\n * const schemaEvolution = Effect.gen(function* () {\n *   const manager = yield* SchemaFirstDevelopment.create(config)\n *\n *   // Load current production schema\n *   const currentSchema = yield* manager.loadDeployedSchema('production')\n *\n *   // Import new schema version\n *   const newSchema = yield* manager.importSchema(newSchemaSDL, '2.0.0')\n *\n *   // Check compatibility\n *   const compatibility = yield* manager.checkCompatibility(currentSchema, newSchema)\n *\n *   return yield* Match.value(compatibility).pipe(\n *     Match.tag('Compatible', ({ changes }) =>\n *       Effect.gen(function* () {\n *         yield* logger.info('Schema is compatible', { changes })\n *         return yield* manager.deploySchema(newSchema)\n *       })\n *     ),\n *     Match.tag('BreakingChanges', ({ breakingChanges, changes }) =>\n *       Effect.gen(function* () {\n *         yield* logger.warn('Breaking changes detected', { breakingChanges })\n *\n *         // Generate evolution strategy\n *         const strategy = yield* manager.generateEvolutionStrategy(changes)\n *\n *         // Apply changes in staging first\n *         yield* manager.applyChanges(strategy, 'staging')\n *\n *         // Validate in staging\n *         yield* manager.validateDeployment('staging')\n *\n *         // Deploy to production with blue-green strategy\n *         return yield* manager.deployWithStrategy(newSchema, 'blue-green')\n *       })\n *     ),\n *     Match.tag('Incompatible', ({ errors }) =>\n *       Effect.fail(new ValidationError(\n *         `Schema incompatible: ${errors.map(e => e.message).join(', ')}`\n *       ))\n *     ),\n *     Match.exhaustive\n *   )\n * })\n * ```\n *\n * @example Code generation with custom templates\n * ```typescript\n * const codeGeneration = Effect.gen(function* () {\n *   const generator = yield* SchemaFirstDevelopment.createCodeGenerator({\n *     templates: {\n *       entity: './templates/entity.hbs',\n *       resolver: './templates/resolver.hbs',\n *       types: './templates/types.hbs'\n *     },\n *     outputDir: './src/generated',\n *     naming: {\n *       entities: 'PascalCase',\n *       fields: 'camelCase',\n *       resolvers: 'camelCase'\n *     }\n *   })\n *\n *   const schema = yield* loadGraphQLSchema('./schema.graphql')\n *\n *   // Generate ultra-strict entity builders\n *   yield* generator.generateEntities(schema, {\n *     builderType: 'ultra-strict',\n *     includeValidation: true,\n *     includeResolvers: true\n *   })\n *\n *   // Generate TypeScript types\n *   yield* generator.generateTypes(schema, {\n *     includeScalars: true,\n *     includeEnums: true,\n *     includeInputTypes: true\n *   })\n *\n *   // Generate resolver templates\n *   yield* generator.generateResolvers(schema, {\n *     includeSubscriptions: false,\n *     includeDataLoaders: true,\n *     errorHandling: 'effect-ts'\n *   })\n * })\n * ```\n *\n * @example Hot reloading development workflow\n * ```typescript\n * const developmentWorkflow = Effect.gen(function* () {\n *   const watcher = yield* SchemaFirstDevelopment.createWatcher({\n *     watchPaths: ['./schemas/schema.graphql'],\n *     debounceMs: 500,\n *     validationLevel: 'ultra-strict'\n *   })\n *\n *   // Set up file watching with automatic regeneration\n *   yield* watcher.start()\n *\n *   return watcher\n * })\n * ```\n *\n * @example Schema composition with multiple subgraphs\n * ```typescript\n * const multiSubgraphComposition = Effect.gen(function* () {\n *   const composer = yield* SchemaFirstDevelopment.createComposer({\n *     subgraphs: [\n *       { name: 'users', schema: './schemas/users.graphql', url: 'http://users:4001' },\n *       { name: 'products', schema: './schemas/products.graphql', url: 'http://products:4002' },\n *       { name: 'orders', schema: './schemas/orders.graphql', url: 'http://orders:4003' }\n *     ],\n *     composition: {\n *       strategy: 'incremental',\n *       validation: 'strict',\n *       optimization: true\n *     }\n *   })\n *\n *   // Compose schemas with entity relationship analysis\n *   const composition = yield* composer.compose().pipe(\n *     Effect.tap(result =>\n *       logger.info('Schema composition completed', {\n *         entities: result.entities.length,\n *         subgraphs: result.subgraphs.length,\n *         queryPlanComplexity: result.metadata.complexity\n *       })\n *     )\n *   )\n *\n *   // Validate entity relationships\n *   const validation = yield* composer.validateEntityRelationships(composition)\n *\n *   // Generate optimized query plans\n *   const optimized = yield* composer.optimizeQueryPlans(composition)\n *\n *   return optimized\n * })\n * ```\n *\n * @category Schema-First Development\n * @see {@link https://www.apollographql.com/docs/federation/federated-types/composition/ | Federation Composition}\n * @see {@link https://graphql-code-generator.com/ | GraphQL Code Generator}\n */\n\nimport * as Context from 'effect/Context'\nimport * as Data from 'effect/Data'\nimport * as Effect from 'effect/Effect'\nimport { pipe } from 'effect/Function'\nimport * as Match from 'effect/Match'\nimport { Kind, type DocumentNode, type GraphQLSchema } from 'graphql'\n\nimport type { ValidatedEntity } from '@api/advanced'\n// Ultra-strict imports removed due to type system complexity\n\n// ============================================================================\n// Core Schema-First Types\n// ============================================================================\n\n/**\n * Schema development lifecycle states\n */\nexport type SchemaLifecycleState = Data.TaggedEnum<{\n  readonly Draft: { readonly schema: DocumentNode; readonly version: string }\n  readonly Validated: {\n    readonly schema: DocumentNode\n    readonly entities: readonly ValidatedEntity<unknown, unknown, unknown>[]\n    readonly version: string\n  }\n  readonly Composed: {\n    readonly federatedSchema: GraphQLSchema\n    readonly subgraphs: readonly string[]\n    readonly version: string\n  }\n  readonly Deployed: {\n    readonly federatedSchema: GraphQLSchema\n    readonly deploymentId: string\n    readonly version: string\n  }\n  readonly Deprecated: {\n    readonly schema: DocumentNode\n    readonly replacedBy: string\n    readonly version: string\n  }\n}>\n\nexport const SchemaLifecycleState = Data.taggedEnum<SchemaLifecycleState>()\n\n/**\n * Schema evolution operations\n */\nexport type SchemaEvolution = Data.TaggedEnum<{\n  readonly AddField: {\n    readonly entityType: string\n    readonly fieldName: string\n    readonly fieldType: string\n    readonly isBreaking: boolean\n  }\n  readonly RemoveField: {\n    readonly entityType: string\n    readonly fieldName: string\n    readonly isBreaking: boolean\n  }\n  readonly ChangeFieldType: {\n    readonly entityType: string\n    readonly fieldName: string\n    readonly oldType: string\n    readonly newType: string\n    readonly isBreaking: boolean\n  }\n  readonly AddDirective: {\n    readonly entityType: string\n    readonly fieldName: string | undefined\n    readonly directive: string\n    readonly isBreaking: boolean\n  }\n  readonly RemoveDirective: {\n    readonly entityType: string\n    readonly fieldName: string | undefined\n    readonly directive: string\n    readonly isBreaking: boolean\n  }\n  readonly AddEntity: { readonly entityType: string; readonly isBreaking: boolean }\n  readonly RemoveEntity: { readonly entityType: string; readonly isBreaking: boolean }\n}>\n\nexport const SchemaEvolution = Data.taggedEnum<SchemaEvolution>()\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\nexport class SchemaFirstError extends Data.TaggedError('SchemaFirstError')<{\n  readonly message: string\n  readonly schemaPath?: readonly string[]\n  readonly suggestion?: string\n}> {}\n\nexport class SchemaEvolutionError extends Data.TaggedError('SchemaEvolutionError')<{\n  readonly message: string\n  readonly evolution: SchemaEvolution\n  readonly conflictingChanges?: readonly SchemaEvolution[]\n}> {}\n\nexport class CodeGenerationError extends Data.TaggedError('CodeGenerationError')<{\n  readonly message: string\n  readonly targetLanguage: string\n  readonly entityType: string\n}> {}\n\n// ============================================================================\n// Schema-First Services\n// ============================================================================\n\nexport interface SchemaFirstService {\n  readonly parseSchemaDefinition: (\n    schemaSource: string\n  ) => Effect.Effect<DocumentNode, SchemaFirstError>\n\n  readonly extractEntitiesFromSchema: (\n    schema: DocumentNode\n  ) => Effect.Effect<readonly string[], SchemaFirstError>\n\n  readonly generateEntityBuilders: (\n    schema: DocumentNode\n  ) => Effect.Effect<readonly ValidatedEntity<unknown, unknown, unknown>[], SchemaFirstError>\n\n  readonly validateSchemaEvolution: (\n    currentSchema: DocumentNode,\n    proposedSchema: DocumentNode\n  ) => Effect.Effect<readonly SchemaEvolution[], SchemaEvolutionError>\n\n  readonly generateResolverStubs: <A, I, R>(\n    entities: readonly ValidatedEntity<A, I, R>[]\n  ) => Effect.Effect<string, CodeGenerationError, never>\n\n  readonly generateTypeDefinitions: <A, I, R>(\n    entities: readonly ValidatedEntity<A, I, R>[],\n    language: 'typescript' | 'go' | 'java' | 'python'\n  ) => Effect.Effect<string, CodeGenerationError, never>\n}\n\nexport const SchemaFirstService = Context.GenericTag<SchemaFirstService>(\n  '@federation/SchemaFirstService'\n)\n\n// ============================================================================\n// Schema-First Service Implementation\n// ============================================================================\n\nexport const createSchemaFirstService = (): SchemaFirstService => ({\n  parseSchemaDefinition: (schemaSource: string) =>\n    pipe(\n      Effect.try(() => {\n        // Simplified parsing - in real implementation would use graphql-js parser\n        // Check for basic validity\n        if (!schemaSource?.includes('type')) {\n          throw new Error('Invalid GraphQL schema')\n        }\n        return {\n          kind: Kind.DOCUMENT,\n          definitions: [],\n        } satisfies DocumentNode\n      }),\n      Effect.mapError(\n        error =>\n          new SchemaFirstError({\n            message: `Failed to parse schema: ${error}`,\n            suggestion: 'Ensure the schema follows valid GraphQL SDL syntax',\n          })\n      )\n    ),\n\n  extractEntitiesFromSchema: (schema: DocumentNode) =>\n    pipe(\n      Effect.succeed(schema),\n      Effect.map(_doc => {\n        // Simplified extraction - would analyze AST for @key directives\n        return ['User', 'Product', 'Order'] as readonly string[]\n      }),\n      Effect.catchAll(error =>\n        Effect.fail(\n          new SchemaFirstError({\n            message: `Failed to extract entities: ${error}`,\n            suggestion: 'Ensure entities have proper @key directives',\n          })\n        )\n      )\n    ),\n\n  generateEntityBuilders: (schema: DocumentNode) =>\n    pipe(\n      Effect.succeed(schema),\n      Effect.map(() => {\n        // Generate mock entity builders for testing\n        // Return empty array for now - proper implementation would analyze schema\n        return [] as readonly ValidatedEntity<unknown, unknown, unknown>[]\n      }),\n      Effect.catchAll(error =>\n        Effect.fail(\n          new SchemaFirstError({\n            message: `Failed to generate entity builders: ${error}`,\n            suggestion: 'Ensure schema is valid',\n          })\n        )\n      )\n    ),\n\n  validateSchemaEvolution: (currentSchema: DocumentNode, proposedSchema: DocumentNode) =>\n    pipe(\n      Effect.succeed([currentSchema, proposedSchema]),\n      Effect.map(([_current, _proposed]) => {\n        // Simplified evolution analysis\n        const evolutions: readonly SchemaEvolution[] = [\n          SchemaEvolution.AddField({\n            entityType: 'User',\n            fieldName: 'lastLoginAt',\n            fieldType: 'DateTime',\n            isBreaking: false,\n          }),\n          SchemaEvolution.ChangeFieldType({\n            entityType: 'Product',\n            fieldName: 'price',\n            oldType: 'Float',\n            newType: 'Decimal',\n            isBreaking: true,\n          }),\n        ]\n        return evolutions as readonly SchemaEvolution[]\n      }),\n      Effect.catchAll(error =>\n        Effect.fail(\n          new SchemaEvolutionError({\n            message: `Schema evolution validation failed: ${error}`,\n            evolution: SchemaEvolution.AddField({\n              entityType: 'Unknown',\n              fieldName: 'unknown',\n              fieldType: 'String',\n              isBreaking: false,\n            }),\n          })\n        )\n      )\n    ),\n\n  generateResolverStubs: <A, I, R>(entities: readonly ValidatedEntity<A, I, R>[]) =>\n    pipe(\n      Effect.succeed(entities),\n      Effect.map(entities => {\n        const stubs = entities\n          .map(\n            entity => `\n// Resolver for ${entity.typename}\nexport const ${entity.typename}Resolvers = {\n  Query: {\n    ${entity.typename.toLowerCase()}: async (parent: unknown, args: unknown, context: unknown) => {\n      // TODO: Implement ${entity.typename} query resolver\n      return Effect.runPromise(\n        pipe(\n          Effect.succeed(args),\n          // Add your business logic here\n          Effect.map(data => data)\n        )\n      )\n    }\n  },\n\n  ${entity.typename}: {\n    // Field resolvers\n    ${entity.keys\n      .map(\n        key => `\n    ${key.field}: (parent: unknown) => parent.${key.field}`\n      )\n      .join(',')}\n  }\n}`\n          )\n          .join('\\n\\n')\n\n        return `import * as Effect from \"effect/Effect\"\\nimport { pipe } from \"effect/Function\"\\n\\n${stubs}`\n      }),\n      Effect.catchAll(error =>\n        Effect.fail(\n          new CodeGenerationError({\n            message: `Failed to generate resolver stubs: ${error}`,\n            targetLanguage: 'typescript',\n            entityType: 'multiple',\n          })\n        )\n      )\n    ),\n\n  generateTypeDefinitions: <A, I, R>(\n    entities: readonly ValidatedEntity<A, I, R>[],\n    language: 'typescript' | 'go' | 'java' | 'python'\n  ) =>\n    pipe(\n      Effect.succeed({ entities, language }),\n      Effect.flatMap(({ entities, language }) =>\n        pipe(\n          Match.value(language),\n          Match.when('typescript', () => generateTypeScriptTypes(entities)),\n          Match.when('go', () => generateGoTypes(entities)),\n          Match.when('java', () => generateJavaTypes(entities)),\n          Match.when('python', () => generatePythonTypes(entities)),\n          Match.exhaustive\n        )\n      ),\n      Effect.catchAll(error =>\n        Effect.fail(\n          new CodeGenerationError({\n            message: `Failed to generate ${language} types: ${error}`,\n            targetLanguage: language,\n            entityType: 'multiple',\n          })\n        )\n      )\n    ),\n})\n\n// ============================================================================\n// Type Generation Functions\n// ============================================================================\n\nconst generateTypeScriptTypes = <A, I, R>(\n  entities: readonly ValidatedEntity<A, I, R>[]\n): Effect.Effect<string, never> =>\n  Effect.succeed(\n    entities.length === 0\n      ? `// TypeScript type definitions for federated entities\nexport interface BaseEntity {\n  readonly id: string\n}\n\n// Add your entity interfaces here\n`\n      : entities\n          .map(\n            entity => `\nexport interface ${entity.typename} {\n  ${entity.keys.map(key => `readonly ${key.field}: string`).join('\\n  ')}\n  // Additional fields from schema would be generated here\n}\n\nexport type ${entity.typename}Input = Omit<${entity.typename}, 'id'>\n`\n          )\n          .join('\\n')\n  )\n\nconst generateGoTypes = <A, I, R>(\n  entities: readonly ValidatedEntity<A, I, R>[]\n): Effect.Effect<string, never> =>\n  Effect.succeed(\n    `package federation\\n\\n` +\n      entities\n        .map(\n          entity => `\ntype ${entity.typename} struct {\n  ${entity.keys.map(key => `${key.field.charAt(0).toUpperCase() + key.field.slice(1)} string \\`json:\"${key.field}\"\\``).join('\\n  ')}\n  // Additional fields from schema would be generated here\n}\n`\n        )\n        .join('\\n')\n  )\n\nconst generateJavaTypes = <A, I, R>(\n  entities: readonly ValidatedEntity<A, I, R>[]\n): Effect.Effect<string, never> =>\n  Effect.succeed(\n    entities\n      .map(\n        entity => `\npublic class ${entity.typename} {\n  ${entity.keys.map(key => `private String ${key.field};`).join('\\n  ')}\n\n  // Constructors, getters, and setters would be generated here\n}\n`\n      )\n      .join('\\n')\n  )\n\nconst generatePythonTypes = <A, I, R>(\n  entities: readonly ValidatedEntity<A, I, R>[]\n): Effect.Effect<string, never> =>\n  Effect.succeed(\n    `from dataclasses import dataclass\\nfrom typing import Optional\\n\\n` +\n      entities\n        .map(\n          entity => `\n@dataclass\nclass ${entity.typename}:\n    ${entity.keys.map(key => `${key.field}: str`).join('\\n    ')}\n    # Additional fields from schema would be generated here\n`\n        )\n        .join('\\n')\n  )\n\n// ============================================================================\n// Schema-First Workflow Orchestrator\n// ============================================================================\n\nexport interface SchemaFirstWorkflow {\n  readonly developSchema: (\n    schemaSource: string\n  ) => Effect.Effect<SchemaLifecycleState, SchemaFirstError>\n\n  readonly evolveSchema: (\n    currentState: SchemaLifecycleState,\n    proposedSchema: string\n  ) => Effect.Effect<SchemaLifecycleState, SchemaEvolutionError>\n\n  readonly generateCode: (\n    state: SchemaLifecycleState,\n    targets: readonly ('resolvers' | 'types')[]\n  ) => Effect.Effect<Record<string, string>, CodeGenerationError>\n}\n\nexport const createSchemaFirstWorkflow = (\n  schemaFirstService: SchemaFirstService\n): SchemaFirstWorkflow => ({\n  developSchema: (schemaSource: string) =>\n    pipe(\n      schemaFirstService.parseSchemaDefinition(schemaSource),\n      Effect.flatMap(schema =>\n        pipe(\n          Effect.succeed(schema),\n          Effect.map(() =>\n            SchemaLifecycleState.Validated({\n              schema,\n              entities: [],\n              version: '1.0.0',\n            })\n          )\n        )\n      )\n    ),\n\n  evolveSchema: (currentState: SchemaLifecycleState, proposedSchema: string) =>\n    pipe(\n      Match.value(currentState),\n      Match.tag('Validated', ({ schema: currentSchema }) =>\n        pipe(\n          schemaFirstService.parseSchemaDefinition(proposedSchema),\n          Effect.mapError(\n            (error: SchemaFirstError) =>\n              new SchemaEvolutionError({\n                message: error.message,\n                evolution: SchemaEvolution.AddField({\n                  entityType: 'Unknown',\n                  fieldName: 'unknown',\n                  fieldType: 'String',\n                  isBreaking: false,\n                }),\n              })\n          ),\n          Effect.flatMap(proposedSchemaDoc =>\n            pipe(\n              schemaFirstService.validateSchemaEvolution(currentSchema, proposedSchemaDoc),\n              Effect.flatMap((evolutions: readonly SchemaEvolution[]) => {\n                const hasBreakingChanges = evolutions.some(evo =>\n                  Match.value(evo).pipe(\n                    Match.tag('AddField', ({ isBreaking }) => isBreaking),\n                    Match.tag('RemoveField', ({ isBreaking }) => isBreaking),\n                    Match.tag('ChangeFieldType', ({ isBreaking }) => isBreaking),\n                    Match.orElse(() => false)\n                  )\n                )\n\n                if (hasBreakingChanges) {\n                  return Effect.fail(\n                    new SchemaEvolutionError({\n                      message: 'Schema evolution contains breaking changes',\n                      evolution:\n                        evolutions[0] ??\n                        SchemaEvolution.AddField({\n                          entityType: 'Unknown',\n                          fieldName: 'unknown',\n                          fieldType: 'String',\n                          isBreaking: true,\n                        }),\n                      conflictingChanges: evolutions,\n                    })\n                  )\n                }\n\n                return pipe(\n                  Effect.succeed(proposedSchemaDoc),\n                  Effect.map(() =>\n                    SchemaLifecycleState.Validated({\n                      schema: proposedSchemaDoc,\n                      entities: [],\n                      version: '1.1.0',\n                    })\n                  ),\n                  Effect.mapError(\n                    (error: SchemaFirstError) =>\n                      new SchemaEvolutionError({\n                        message: error.message,\n                        evolution: SchemaEvolution.AddField({\n                          entityType: 'Unknown',\n                          fieldName: 'unknown',\n                          fieldType: 'String',\n                          isBreaking: false,\n                        }),\n                      })\n                  )\n                )\n              })\n            )\n          )\n        )\n      ),\n      Match.orElse(_state =>\n        Effect.fail(\n          new SchemaEvolutionError({\n            message: 'Can only evolve validated schemas',\n            evolution: SchemaEvolution.AddField({\n              entityType: 'Unknown',\n              fieldName: 'unknown',\n              fieldType: 'String',\n              isBreaking: false,\n            }),\n            conflictingChanges: [],\n          })\n        )\n      )\n    ),\n\n  generateCode: (state: SchemaLifecycleState, targets: readonly ('resolvers' | 'types')[]) =>\n    pipe(\n      Match.value(state),\n      Match.tag('Validated', ({ entities }) =>\n        pipe(\n          Effect.all(\n            targets.map(target =>\n              pipe(\n                Match.value(target),\n                Match.when('resolvers', () =>\n                  pipe(\n                    schemaFirstService.generateResolverStubs(entities),\n                    Effect.map(code => [target, code] as const)\n                  )\n                ),\n                Match.when('types', () =>\n                  pipe(\n                    schemaFirstService.generateTypeDefinitions(entities, 'typescript'),\n                    Effect.map(code => [target, code] as const)\n                  )\n                ),\n                Match.exhaustive\n              )\n            )\n          ),\n          Effect.map(results => Object.fromEntries(results))\n        )\n      ),\n      Match.orElse(() =>\n        Effect.fail(\n          new CodeGenerationError({\n            message: 'Can only generate code from validated schemas',\n            targetLanguage: 'typescript',\n            entityType: 'multiple',\n          })\n        )\n      )\n    ),\n})\n\n// ============================================================================\n// Public API\n// ============================================================================\n\nexport namespace SchemaFirst {\n  export const Service = {\n    create: createSchemaFirstService,\n    Tag: SchemaFirstService,\n  }\n\n  export const Workflow = {\n    create: createSchemaFirstWorkflow,\n  }\n\n  export const State = SchemaLifecycleState\n  export const Evolution = SchemaEvolution\n}\n","/**\n * Layer compositions for Federation Framework\n *\n * Pre-composed Effect layers for different deployment environments and use cases,\n * providing dependency injection patterns, service composition, and environment-specific\n * configurations for federated GraphQL applications.\n *\n * ## üèóÔ∏è Layer Architecture\n *\n * Layers in Effect-TS provide a powerful dependency injection system that allows you to:\n * - **Compose Services**: Combine multiple services into cohesive units\n * - **Environment Isolation**: Different configurations for dev/staging/production\n * - **Testability**: Easy mocking and testing with layer substitution\n * - **Resource Management**: Automatic resource acquisition and cleanup\n * - **Service Dependencies**: Declarative dependency management between services\n *\n * ## üåç Environment Layers\n *\n * ### Development Layer\n * - Pretty-printed console logs for easy reading\n * - Debug-level logging for detailed troubleshooting\n * - Local service configurations\n * - Hot-reload friendly settings\n *\n * ### Production Layer\n * - Structured JSON logging for log aggregation\n * - Info-level logging to reduce noise\n * - Production-ready configurations\n * - Performance optimizations enabled\n *\n * ### Testing Layer\n * - Minimal logging to avoid test output noise\n * - Fast configurations for test execution\n * - Mock-friendly service implementations\n * - Deterministic behavior for testing\n *\n * @example Basic layer usage\n * ```typescript\n * import { DevelopmentLayerLive } from '@cqrs/federation'\n * import { Effect } from 'effect'\n *\n * const myProgram = Effect.gen(function* () {\n *   const config = yield* FederationConfigService\n *   const logger = yield* FederationLogger\n *\n *   yield* logger.info('Application starting', {\n *     port: config.server.port,\n *     environment: 'development'\n *   })\n * })\n *\n * // Provide all necessary services for development\n * const runnable = myProgram.pipe(Effect.provide(DevelopmentLayerLive))\n * Effect.runPromise(runnable)\n * ```\n *\n * @example Environment-specific deployment\n * ```typescript\n * import { createEnvironmentLayer } from '@cqrs/federation'\n *\n * const environment = process.env.NODE_ENV || 'development'\n * const layer = createEnvironmentLayer(environment)\n *\n * const startServer = Effect.gen(function* () {\n *   const config = yield* FederationConfigService\n *   const logger = yield* FederationLogger\n *\n *   yield* logger.info('Server starting', {\n *     environment,\n *     port: config.server.port\n *   })\n *\n *   // Start GraphQL server...\n * })\n *\n * const program = startServer.pipe(Effect.provide(layer))\n * ```\n *\n * @example Custom layer composition\n * ```typescript\n * import { Layer } from 'effect'\n * import { CoreServicesLive, FederationLoggerLive } from '@cqrs/federation'\n *\n * // Create custom layer with additional services\n * const CustomDatabaseService = Layer.succeed(DatabaseService, {\n *   query: (sql: string) => Effect.succeed([]),\n *   transaction: <A>(effect: Effect.Effect<A>) => effect\n * })\n *\n * const CustomLayerLive = Layer.mergeAll(\n *   CoreServicesLive,\n *   CustomDatabaseService,\n *   Logger.json // JSON structured logging\n * )\n *\n * const application = myBusinessLogic.pipe(Effect.provide(CustomLayerLive))\n * ```\n *\n * @example Layer testing and mocking\n * ```typescript\n * import { TestLayerLive } from '@cqrs/federation'\n * import { Layer } from 'effect'\n *\n * // Mock external services for testing\n * const MockExternalService = Layer.succeed(ExternalService, {\n *   fetchData: (id: string) => Effect.succeed({ id, data: 'test-data' }),\n *   isHealthy: () => Effect.succeed(true)\n * })\n *\n * const TestEnvironment = Layer.mergeAll(\n *   TestLayerLive,\n *   MockExternalService\n * )\n *\n * // Run tests with mocked dependencies\n * const testProgram = Effect.gen(function* () {\n *   const service = yield* ExternalService\n *   const result = yield* service.fetchData('test-id')\n *\n *   expect(result.data).toBe('test-data')\n * })\n *\n * test('should work with mocked services', async () => {\n *   await Effect.runPromise(testProgram.pipe(Effect.provide(TestEnvironment)))\n * })\n * ```\n *\n * @example Resource management with layers\n * ```typescript\n * import { Effect, Layer } from 'effect'\n *\n * // Layer with resource management\n * const DatabaseConnectionLive = Layer.scoped(\n *   DatabaseConnection,\n *   Effect.gen(function* () {\n *     const config = yield* FederationConfigService\n *\n *     // Acquire database connection\n *     const connection = yield* Effect.acquireRelease(\n *       connectToDatabase(config.database.url),\n *       (conn) => closeConnection(conn)\n *     )\n *\n *     return {\n *       query: (sql: string) => executeQuery(connection, sql),\n *       transaction: <A>(effect: Effect.Effect<A>) =>\n *         withTransaction(connection, effect)\n *     }\n *   })\n * )\n *\n * const AppWithDatabase = Layer.mergeAll(\n *   CoreServicesLive,\n *   DatabaseConnectionLive\n * )\n * ```\n *\n * @example Multi-tenancy with layers\n * ```typescript\n * const createTenantLayer = (tenantId: string) =>\n *   Layer.succeed(TenantContext, { tenantId }).pipe(\n *     Layer.merge(CoreServicesLive)\n *   )\n *\n * const handleTenantRequest = (tenantId: string, request: Request) =>\n *   processRequest(request).pipe(\n *     Effect.provide(createTenantLayer(tenantId))\n *   )\n * ```\n *\n * @category Core Services\n * @see {@link https://effect.website/docs/guides/layers | Effect Layers Guide}\n * @see {@link https://effect.website/docs/guides/dependency-injection | Effect Dependency Injection}\n */\n\nimport * as Layer from 'effect/Layer'\nimport * as Logger from 'effect/Logger'\nimport { FederationConfigLive } from './config.js'\nimport { FederationLoggerLive, developmentLogger, productionLogger, testLogger } from './logger.js'\n\n// Base layer that all applications need\nexport const CoreServicesLive = Layer.mergeAll(FederationConfigLive, FederationLoggerLive)\n\n// Development environment layer\nexport const DevelopmentLayerLive = Layer.mergeAll(\n  CoreServicesLive,\n  developmentLogger,\n  Logger.pretty // Pretty-print logs in development\n)\n\n// Production environment layer\nexport const ProductionLayerLive = Layer.mergeAll(\n  CoreServicesLive,\n  productionLogger,\n  Logger.json // JSON logs for production\n)\n\n// Testing environment layer\nexport const TestLayerLive = Layer.mergeAll(CoreServicesLive, testLogger)\n\n// Minimal layer for basic functionality\nexport const MinimalLayerLive = FederationConfigLive\n\n/**\n * Helper function to create environment-specific layers\n */\nexport const createEnvironmentLayer = (environment?: string) => {\n  switch (environment) {\n    case 'production':\n      return ProductionLayerLive\n    case 'test':\n      return TestLayerLive\n    case 'development':\n    default:\n      return DevelopmentLayerLive\n  }\n}\n","import * as Effect from 'effect/Effect'\nimport { pipe } from 'effect/Function'\nimport * as Match from 'effect/Match'\nimport * as Option from 'effect/Option'\nimport * as Schema from 'effect/Schema'\nimport * as AST from 'effect/SchemaAST'\nimport {\n  GraphQLBoolean,\n  GraphQLEnumType,\n  GraphQLFloat,\n  GraphQLID,\n  GraphQLInputObjectType,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLString,\n  GraphQLUnionType,\n  isOutputType as isGraphQLOutputType,\n  type GraphQLFieldConfig,\n  type GraphQLInputFieldConfig,\n  type GraphQLInputType,\n  type GraphQLOutputType,\n  type GraphQLType,\n  type ThunkObjMap,\n} from 'graphql'\nimport { ErrorFactory } from '@runtime/core'\nimport type { TypeConversionError } from '@runtime/core'\n\nconst MAX_RECURSION_DEPTH = 10 as const\n\n/**\n * Type conversion context with caching and configuration\n *\n * Context object that manages the conversion of Effect Schema AST nodes to GraphQL types,\n * providing caching for performance, custom scalar handling, and safety features like\n * recursion depth limiting.\n *\n * @example Basic usage\n * ```typescript\n * const context = createConversionContext(false, {\n *   DateTime: new GraphQLScalarType({ name: 'DateTime' }),\n *   JSON: GraphQLJSON\n * })\n *\n * const graphqlType = yield* convertSchemaToGraphQL(\n *   Schema.Struct({ id: Schema.String, createdAt: Schema.Date }),\n *   context\n * )\n * ```\n *\n * @example Input type conversion\n * ```typescript\n * const inputContext = createConversionContext(true, {}, {\n *   strictMode: true,\n *   maxDepth: 5\n * })\n *\n * const inputType = yield* convertSchemaToGraphQL(CreateUserSchema, inputContext)\n * ```\n *\n * @category Schema Processing\n */\nexport interface TypeConversionContext {\n  readonly cache: Map<string, GraphQLType>\n  readonly isInput: boolean\n  readonly scalars: Record<string, GraphQLScalarType>\n  readonly depth: number\n  readonly maxDepth: number\n  readonly strictMode: boolean\n}\n\n/**\n * Create a new type conversion context with specified configuration\n *\n * Factory function for creating a TypeConversionContext with appropriate defaults\n * and customization options for different conversion scenarios.\n *\n * @param isInput - Whether to create context for GraphQL input types (default: false)\n * @param scalars - Custom scalar type mappings for conversion\n * @param options - Additional configuration options\n * @param options.maxDepth - Maximum recursion depth to prevent infinite loops (default: 10)\n * @param options.strictMode - Enable strict type validation during conversion (default: false)\n * @returns Configured conversion context ready for use\n *\n * @example Creating output type context\n * ```typescript\n * const outputContext = createConversionContext(false, {\n *   UUID: UUIDScalarType,\n *   DateTime: DateTimeScalarType\n * })\n * ```\n *\n * @example Creating input type context with strict mode\n * ```typescript\n * const inputContext = createConversionContext(true, {}, {\n *   maxDepth: 8,\n *   strictMode: true\n * })\n * ```\n *\n * @category Schema Processing\n */\nexport const createConversionContext = (\n  isInput = false,\n  scalars: Record<string, GraphQLScalarType> = {},\n  options: {\n    readonly maxDepth?: number\n    readonly strictMode?: boolean\n  } = {}\n): TypeConversionContext => ({\n  cache: new Map(),\n  isInput,\n  scalars,\n  depth: 0,\n  maxDepth: options.maxDepth ?? MAX_RECURSION_DEPTH,\n  strictMode: options.strictMode ?? true,\n})\n\n/**\n * Schema to GraphQL Type Conversion Pipeline\n *\n * Advanced AST-based transformation with comprehensive type support and pattern matching.\n *\n * Features:\n * - Exhaustive pattern matching over AST nodes\n * - Recursive type conversion with cycle detection\n * - Branded type mapping to GraphQL types\n * - Custom scalar type support\n * - Input/Output type distinction\n * - Comprehensive error handling\n */\nexport namespace ASTConversion {\n  /**\n   * Convert Effect Schema to GraphQL type with comprehensive error handling\n   */\n  export const schemaToGraphQLType = (\n    schema: Schema.Schema<unknown>,\n    context: TypeConversionContext = createConversionContext()\n  ): Effect.Effect<GraphQLOutputType | GraphQLInputType, TypeConversionError> => {\n    if (context.depth > context.maxDepth) {\n      return Effect.fail(\n        ErrorFactory.typeConversion(\n          `Maximum recursion depth (${context.maxDepth}) exceeded`,\n          'depth_exceeded'\n        )\n      )\n    }\n\n    const ast = schema.ast\n    const cacheKey = generateCacheKey(ast, context.isInput)\n\n    // Check cache first\n    const cachedType = context.cache.get(cacheKey)\n    if (cachedType) {\n      return Effect.succeed(cachedType as GraphQLOutputType | GraphQLInputType)\n    }\n\n    const nextContext: TypeConversionContext = {\n      ...context,\n      depth: context.depth + 1,\n    }\n\n    return pipe(\n      convertAST(ast, nextContext),\n      Effect.tap(type => Effect.sync(() => context.cache.set(cacheKey, type)))\n    )\n  }\n\n  /**\n   * Convert multiple schemas to GraphQL types concurrently\n   */\n  export const convertSchemasParallel = (\n    schemas: ReadonlyArray<{ readonly name: string; readonly schema: Schema.Schema<unknown> }>,\n    context: TypeConversionContext = createConversionContext()\n  ): Effect.Effect<Record<string, GraphQLOutputType | GraphQLInputType>, TypeConversionError> =>\n    pipe(\n      Effect.all(\n        schemas.map(({ name, schema }) =>\n          pipe(\n            schemaToGraphQLType(schema, context),\n            Effect.map(type => [name, type] as const)\n          )\n        ),\n        { concurrency: 5 }\n      ),\n      Effect.map(pairs => Object.fromEntries(pairs))\n    )\n\n  /**\n   * Create GraphQL schema from Effect Schema registry\n   */\n  export const createGraphQLSchema = (\n    entities: Record<string, Schema.Schema<unknown>>,\n    queries: Record<string, Schema.Schema<unknown>> = {},\n    mutations: Record<string, Schema.Schema<unknown>> = {}\n  ): Effect.Effect<\n    {\n      readonly types: Record<string, GraphQLOutputType>\n      readonly queries: Record<string, GraphQLOutputType>\n      readonly mutations: Record<string, GraphQLOutputType>\n    },\n    TypeConversionError\n  > => {\n    const outputContext = createConversionContext(false)\n\n    return pipe(\n      Effect.all({\n        types: pipe(\n          convertSchemasParallel(\n            Object.entries(entities).map(([name, schema]) => ({ name, schema })),\n            outputContext\n          ),\n          Effect.map(result => filterOutputTypes(result))\n        ),\n        queries: pipe(\n          convertSchemasParallel(\n            Object.entries(queries).map(([name, schema]) => ({ name, schema })),\n            outputContext\n          ),\n          Effect.map(result => filterOutputTypes(result))\n        ),\n        mutations: pipe(\n          convertSchemasParallel(\n            Object.entries(mutations).map(([name, schema]) => ({ name, schema })),\n            outputContext\n          ),\n          Effect.map(result => filterOutputTypes(result))\n        ),\n      })\n    )\n  }\n\n  // === Helper Functions ===\n\n  const filterOutputTypes = (\n    record: Record<string, GraphQLOutputType | GraphQLInputType>\n  ): Record<string, GraphQLOutputType> => {\n    const filtered: Record<string, GraphQLOutputType> = {}\n    for (const [key, type] of Object.entries(record)) {\n      if (isGraphQLOutputType(type)) {\n        filtered[key] = type\n      }\n    }\n    return filtered\n  }\n\n  // === Internal Implementation ===\n\n  /**\n   * Convert AST node using exhaustive pattern matching\n   */\n  const convertAST = (\n    ast: AST.AST,\n    context: TypeConversionContext\n  ): Effect.Effect<GraphQLOutputType | GraphQLInputType, TypeConversionError> =>\n    Match.value(ast).pipe(\n      // Primitive types\n      Match.tag('StringKeyword', () => Effect.succeed(GraphQLString)),\n\n      Match.tag('NumberKeyword', () => Effect.succeed(GraphQLFloat)),\n\n      Match.tag('BooleanKeyword', () => Effect.succeed(GraphQLBoolean)),\n\n      Match.tag('BigIntKeyword', () => Effect.succeed(GraphQLString)), // Represent BigInt as String\n\n      Match.tag('SymbolKeyword', () => Effect.succeed(GraphQLString)), // Represent Symbol as String\n\n      Match.tag('UnknownKeyword', () => Effect.succeed(context.scalars['JSON'] ?? GraphQLString)),\n\n      Match.tag('AnyKeyword', () => Effect.succeed(context.scalars['JSON'] ?? GraphQLString)),\n\n      Match.tag('VoidKeyword', () => Effect.succeed(GraphQLString)), // Void as nullable String\n\n      Match.tag('NeverKeyword', () =>\n        Effect.fail(\n          ErrorFactory.typeConversion('Never type cannot be represented in GraphQL', 'never_type')\n        )\n      ),\n\n      // Literal types\n      Match.tag('Literal', ast => convertLiteral(ast, context)),\n\n      // Refinement types (branded types)\n      Match.tag('Refinement', ast => convertRefinement(ast, context)),\n\n      // Object types\n      Match.tag('TypeLiteral', ast => convertTypeLiteral(ast, context)),\n\n      // Union types\n      Match.tag('Union', ast => convertUnion(ast, context)),\n\n      // Enum types\n      Match.tag('Enums', ast => convertEnums(ast, context)),\n\n      // Array types\n      Match.tag('TupleType', ast => convertTuple(ast, context)),\n\n      // Template literal types\n      Match.tag('TemplateLiteral', ast => convertTemplateLiteral(ast, context)),\n\n      // Declaration types\n      Match.tag('Declaration', ast => convertDeclaration(ast, context)),\n\n      // Transformation types\n      Match.tag('Transformation', ast => schemaToGraphQLType(Schema.make(ast.from), context)),\n\n      // Suspend types (lazy evaluation)\n      Match.tag('Suspend', ast => convertSuspend(ast, context)),\n\n      // Catch-all for unsupported types\n      Match.orElse(unsupportedAst =>\n        Effect.fail(\n          ErrorFactory.typeConversion(\n            `Unsupported AST type: ${unsupportedAst._tag}`,\n            unsupportedAst._tag,\n            'astType'\n          )\n        )\n      )\n    )\n\n  /**\n   * Convert literal AST to appropriate GraphQL type\n   */\n  const convertLiteral = (\n    ast: AST.Literal,\n    _context: TypeConversionContext\n  ): Effect.Effect<GraphQLOutputType | GraphQLInputType, TypeConversionError> => {\n    const literalValue = ast.literal\n\n    if (typeof literalValue === 'string') {\n      return Effect.succeed(GraphQLString)\n    } else if (typeof literalValue === 'number') {\n      return Effect.succeed(Number.isInteger(literalValue) ? GraphQLInt : GraphQLFloat)\n    } else if (typeof literalValue === 'boolean') {\n      return Effect.succeed(GraphQLBoolean)\n    } else {\n      return Effect.succeed(GraphQLString) // Default to string for complex literals\n    }\n  }\n\n  /**\n   * Convert refinement AST with branded type mapping\n   */\n  const convertRefinement = (\n    ast: AST.Refinement,\n    context: TypeConversionContext\n  ): Effect.Effect<GraphQLOutputType | GraphQLInputType, TypeConversionError> => {\n    const identifierAnnotation = AST.getAnnotation(AST.IdentifierAnnotationId)(ast)\n    const titleAnnotation = AST.getAnnotation(AST.TitleAnnotationId)(ast)\n\n    return pipe(\n      Effect.fromNullable(identifierAnnotation ?? titleAnnotation),\n      Effect.flatMap((annotation: unknown) => {\n        // The annotation might be wrapped in an Option type\n        let title: string\n        if (typeof annotation === 'string') {\n          title = annotation\n        } else if (annotation !== null && typeof annotation === 'object' && 'value' in annotation) {\n          title = String((annotation as { value: unknown }).value)\n        } else {\n          title = String(annotation)\n        }\n        return Match.value(title).pipe(\n          // Integer type -> GraphQL Int\n          Match.when(\n            t => t === 'Int' || t === 'int',\n            () => Effect.succeed(GraphQLInt)\n          ),\n\n          // ID types -> GraphQL ID\n          Match.when(\n            t => t?.endsWith('Id') || t?.includes('Identity') || t === 'ID',\n            () => Effect.succeed(GraphQLID)\n          ),\n\n          // Email and communication types\n          Match.when(\n            t => t === 'Email' || t === 'EmailAddress',\n            () => Effect.succeed(GraphQLString)\n          ),\n\n          Match.when(\n            t => t === 'Phone' || t === 'PhoneNumber',\n            () => Effect.succeed(GraphQLString)\n          ),\n\n          Match.when(\n            t => t === 'URL' || t === 'Uri' || t === 'Link',\n            () => Effect.succeed(GraphQLString)\n          ),\n\n          // Temporal types\n          Match.when(\n            t => t === 'Timestamp' || t === 'DateTime',\n            () => Effect.succeed(context.scalars['DateTime'] ?? GraphQLString)\n          ),\n\n          Match.when(\n            t => t === 'Date',\n            () => Effect.succeed(context.scalars['Date'] ?? GraphQLString)\n          ),\n\n          Match.when(\n            t => t === 'Time',\n            () => Effect.succeed(context.scalars['Time'] ?? GraphQLString)\n          ),\n\n          // Numeric types with constraints\n          Match.when(\n            t => t === 'Money' || t === 'Currency' || t === 'Amount',\n            () => Effect.succeed(context.scalars['Money'] ?? GraphQLFloat)\n          ),\n\n          Match.when(\n            t => t === 'Percentage',\n            () => Effect.succeed(GraphQLFloat)\n          ),\n\n          Match.when(\n            t => t === 'Version' || t === 'SequenceNumber',\n            () => Effect.succeed(GraphQLInt)\n          ),\n\n          Match.when(\n            t => t === 'Port' || t === 'Count',\n            () => Effect.succeed(GraphQLInt)\n          ),\n\n          // JSON and structured types\n          Match.when(\n            t => t === 'JSON' || t === 'JsonValue',\n            () => Effect.succeed(context.scalars['JSON'] ?? GraphQLString)\n          ),\n\n          // Sensitive types - should not be exposed\n          Match.when(\n            t => t === 'Password' || t === 'Secret' || t === 'Token',\n            sensitiveType =>\n              context.strictMode\n                ? Effect.fail(\n                    ErrorFactory.typeConversion(\n                      `Sensitive type ${sensitiveType} cannot be converted to GraphQL type`,\n                      'sensitive_type',\n                      sensitiveType\n                    )\n                  )\n                : Effect.succeed(GraphQLString)\n          ),\n\n          // Custom scalar fallback\n          Match.when(\n            (t): t is string => Boolean(t && context.scalars[t]),\n            t => Effect.succeed(context.scalars[t])\n          ),\n\n          // Default fallback - delegate to underlying type\n          Match.orElse(() => schemaToGraphQLType(Schema.make(ast.from), context))\n        )\n      }),\n      Effect.orElse(() =>\n        // No title annotation - delegate to underlying type\n        schemaToGraphQLType(Schema.make(ast.from), context)\n      ),\n      Effect.orElse(() => Effect.succeed(GraphQLString)) // Ultimate fallback to ensure we never return undefined\n    ) as Effect.Effect<GraphQLOutputType | GraphQLInputType, TypeConversionError>\n  }\n\n  /**\n   * Convert type literal AST to GraphQL Object/Input type\n   */\n  const convertTypeLiteral = (\n    ast: AST.TypeLiteral,\n    context: TypeConversionContext\n  ): Effect.Effect<GraphQLObjectType | GraphQLInputObjectType, TypeConversionError> => {\n    const typename = generateTypeName(ast, context)\n\n    return pipe(\n      // Convert all property signatures to GraphQL fields\n      Effect.all(\n        ast.propertySignatures.map(propSig =>\n          pipe(\n            schemaToGraphQLType(Schema.make(propSig.type), context),\n            Effect.map(fieldType => {\n              const isOptional = propSig.isOptional\n              const finalType = isOptional ? fieldType : new GraphQLNonNull(fieldType)\n\n              return [\n                String(propSig.name),\n                {\n                  type: finalType,\n                  description: extractDescription(propSig.type),\n                },\n              ] as const\n            })\n          )\n        )\n      ),\n      Effect.map(fields => Object.fromEntries(fields)),\n      Effect.map(fieldConfig => {\n        const description = extractDescription(ast)\n\n        return context.isInput\n          ? new GraphQLInputObjectType({\n              name: `${typename}Input`,\n              description,\n              fields: fieldConfig as ThunkObjMap<GraphQLInputFieldConfig>,\n            })\n          : new GraphQLObjectType({\n              name: typename,\n              description,\n              fields: fieldConfig as ThunkObjMap<GraphQLFieldConfig<unknown, unknown, unknown>>,\n            })\n      })\n    )\n  }\n\n  /**\n   * Convert union AST to GraphQL Union type\n   */\n  const convertUnion = (\n    ast: AST.Union,\n    context: TypeConversionContext\n  ): Effect.Effect<GraphQLUnionType, TypeConversionError> => {\n    if (context.isInput) {\n      return Effect.fail(\n        ErrorFactory.typeConversion(\n          'Union types are not supported in GraphQL input types',\n          'union_input_type'\n        )\n      )\n    }\n\n    const typename = generateTypeName(ast, context)\n\n    return pipe(\n      Effect.all(ast.types.map(type => schemaToGraphQLType(Schema.make(type), context))),\n      Effect.map(\n        types =>\n          new GraphQLUnionType({\n            name: typename,\n            description: extractDescription(ast),\n            types: types.filter(isObjectType) as readonly GraphQLObjectType[],\n            resolveType: value => {\n              // Try to resolve type based on discriminator field\n              if (value !== null && typeof value === 'object' && '_tag' in value) {\n                return String(value._tag)\n              }\n              return undefined\n            },\n          })\n      )\n    )\n  }\n\n  /**\n   * Convert enums AST to GraphQL Enum type\n   */\n  const convertEnums = (\n    ast: AST.Enums,\n    context: TypeConversionContext\n  ): Effect.Effect<GraphQLEnumType, TypeConversionError> => {\n    const typename = generateTypeName(ast, context)\n\n    return Effect.succeed(\n      new GraphQLEnumType({\n        name: typename,\n        description: extractDescription(ast),\n        values: Object.fromEntries(\n          ast.enums.map(([key, value]) => [\n            String(key),\n            {\n              value,\n              description: `Enum value: ${String(value)}`,\n            },\n          ])\n        ),\n      })\n    )\n  }\n\n  /**\n   * Convert tuple AST to GraphQL List type\n   */\n  const convertTuple = (\n    ast: AST.TupleType,\n    context: TypeConversionContext\n  ): Effect.Effect<GraphQLList<GraphQLOutputType>, TypeConversionError> => {\n    if (ast.elements.length === 0) {\n      return Effect.succeed(new GraphQLList(GraphQLString))\n    }\n\n    // For simplicity, use the first element type for the entire list\n    const firstElementType = ast.elements[0]?.type\n\n    if (!firstElementType) {\n      return Effect.succeed(new GraphQLList(GraphQLString))\n    }\n\n    return pipe(\n      schemaToGraphQLType(Schema.make(firstElementType), context),\n      Effect.map(elementType => {\n        if (isGraphQLOutputType(elementType)) {\n          return new GraphQLList(elementType)\n        } else {\n          // Fallback to string for input types\n          return new GraphQLList(GraphQLString)\n        }\n      })\n    )\n  }\n\n  /**\n   * Convert template literal AST to GraphQL String\n   */\n  const convertTemplateLiteral = (\n    _ast: AST.TemplateLiteral,\n    _context: TypeConversionContext\n  ): Effect.Effect<typeof GraphQLString, TypeConversionError> => Effect.succeed(GraphQLString)\n\n  /**\n   * Convert declaration AST by delegating to the declared type\n   */\n  const convertDeclaration = (\n    _ast: AST.Declaration,\n    _context: TypeConversionContext\n  ): Effect.Effect<GraphQLOutputType | GraphQLInputType, TypeConversionError> =>\n    // Simplified declaration handling - access declaration properties safely\n    Effect.succeed(GraphQLString as GraphQLOutputType | GraphQLInputType)\n\n  /**\n   * Convert suspend AST by evaluating the suspended computation\n   */\n  const convertSuspend = (\n    ast: AST.Suspend,\n    context: TypeConversionContext\n  ): Effect.Effect<GraphQLOutputType | GraphQLInputType, TypeConversionError> =>\n    pipe(\n      Effect.sync(() => ast.f()),\n      Effect.flatMap(suspendedAST => schemaToGraphQLType(Schema.make(suspendedAST), context))\n    )\n\n  // === Helper Functions ===\n\n  /**\n   * Generate cache key for AST node\n   */\n  const generateCacheKey = (ast: AST.AST, isInput: boolean): string => {\n    const baseKey = ast._tag\n    const suffix = isInput ? ':input' : ':output'\n\n    if ('annotations' in ast) {\n      const titleAnnotation = AST.getAnnotation(AST.TitleAnnotationId)(ast)\n      if (Option.isSome(titleAnnotation)) {\n        return `${titleAnnotation.value}${suffix}`\n      }\n    }\n\n    return `${baseKey}${suffix}:${ast.toString?.() ?? 'unknown'}`\n  }\n\n  /**\n   * Generate GraphQL type name from AST\n   */\n  const generateTypeName = (ast: AST.AST, context: TypeConversionContext): string => {\n    if ('annotations' in ast) {\n      const titleAnnotation = AST.getAnnotation(AST.TitleAnnotationId)(ast)\n      if (Option.isSome(titleAnnotation)) {\n        return String(titleAnnotation.value)\n      }\n    }\n\n    // Fallback type name generation\n    return `Generated${ast._tag}${context.depth}`\n  }\n\n  /**\n   * Extract description from AST annotations\n   */\n  const extractDescription = (ast: AST.AST): string | undefined => {\n    if ('annotations' in ast) {\n      const descriptionAnnotation = AST.getAnnotation(AST.DescriptionAnnotationId)(ast)\n      if (Option.isSome(descriptionAnnotation)) {\n        return String(descriptionAnnotation.value)\n      }\n    }\n    return undefined\n  }\n\n  /**\n   * Type guard for GraphQL Object types\n   */\n  const isObjectType = (type: GraphQLType): type is GraphQLObjectType => {\n    return type instanceof GraphQLObjectType\n  }\n}\n","/**\n * Runtime Module - Core runtime functionality for the Federation Framework\n * \n * This module contains the essential runtime components including:\n * - Core types, errors, and builders\n * - Effect-TS patterns and services\n * - Schema processing and AST conversion\n * \n * @module Runtime\n * @since 3.0.0\n */\n\n// Core exports\nexport * from './core'\n\n// Effect patterns and services\nexport * from './effect'\n\n// Schema processing\nexport * from './schema'"],"mappings":"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"}