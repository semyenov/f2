{"version":3,"file":"api-BGBs7yZE.js","names":["schema: GraphQLSchema","services: ServiceDefinition[]","fullConfig: FederationCompositionConfig","errors: KeyValidationError[]","errors: DirectiveValidationError[]"],"sources":["../src/api/simple/facade.ts","../src/api/advanced/strict.ts","../src/api/advanced/index.ts","../src/api/index.ts"],"sourcesContent":["/**\n * # Simplified Federation API Facade\n *\n * This module provides a simplified, user-friendly API for common federation patterns.\n * It abstracts away the complexity of Effect-TS for developers who want quick setup\n * while still maintaining all the type safety and performance benefits.\n *\n * @example Quick federation setup\n * ```typescript\n * import { Federation } from '@cqrs/federation'\n *\n * const federation = await Federation.create({\n *   entities: [userEntity, productEntity],\n *   services: ['http://users:4001', 'http://products:4002']\n * })\n *\n * // Start the federation\n * await federation.start()\n * ```\n *\n * @module Facade\n * @since 2.1.0\n */\n\nimport * as Effect from 'effect/Effect'\nimport { pipe } from 'effect/Function'\nimport * as Duration from 'effect/Duration'\nimport * as Layer from 'effect/Layer'\nimport type { GraphQLSchema } from 'graphql'\n\nimport type {\n  FederationEntity,\n  FederationCompositionConfig,\n  ServiceDefinition,\n  EntityResolutionError,\n  ValidationError,\n  EntityReferenceResolver,\n} from '../../runtime/core/types/types.js'\nimport { FederationEntityBuilder, toFederationEntity } from '../../runtime/core/builders/entity-builder.js'\nimport { FederationComposer, FederationComposerLive } from '../../federation/composition/composer.js'\nimport { FederationLoggerLive } from '../../runtime/effect/services/logger.js'\nimport { FederationConfigLive } from '../../runtime/effect/services/config.js'\nimport type * as Schema from 'effect/Schema'\n\n/**\n * Simplified configuration for federation setup\n */\nexport interface SimplifiedFederationConfig {\n  /**\n   * Federation entities to compose\n   */\n  entities: Array<FederationEntity<unknown, unknown, unknown, unknown, Record<string, unknown>>>\n\n  /**\n   * Service URLs or definitions\n   */\n  services: Array<string | ServiceDefinition>\n\n  /**\n   * Optional performance configuration\n   */\n  performance?: {\n    cacheSize?: number\n    batchSize?: number\n    enableMetrics?: boolean\n  }\n\n  /**\n   * Optional resilience configuration\n   */\n  resilience?: {\n    enableCircuitBreakers?: boolean\n    timeoutSeconds?: number\n    maxFailures?: number\n  }\n\n  /**\n   * Optional development configuration\n   */\n  development?: {\n    enableHotReload?: boolean\n    logLevel?: 'debug' | 'info' | 'warn' | 'error'\n    enableDevTools?: boolean\n  }\n}\n\n/**\n * Simplified entity builder configuration\n */\nexport interface SimplifiedEntityConfig<A = unknown, I = A, R = never> {\n  /**\n   * Entity type name\n   */\n  typename: string\n\n  /**\n   * Entity schema\n   */\n  schema: Schema.Schema<A, I, R>\n\n  /**\n   * Key fields for federation\n   */\n  keys: string[]\n\n  /**\n   * Fields to mark as shareable\n   */\n  shareableFields?: string[]\n\n  /**\n   * Fields to mark as inaccessible\n   */\n  inaccessibleFields?: string[]\n\n  /**\n   * Field tags for organization\n   */\n  fieldTags?: Record<string, string[]>\n\n  /**\n   * Reference resolver function\n   */\n  resolveReference?: (reference: unknown) => Effect.Effect<A | null, EntityResolutionError, never>\n}\n\n/**\n * Main Federation facade class providing simplified API\n */\nexport class Federation {\n  private constructor(\n    private readonly schema: GraphQLSchema,\n    _config: SimplifiedFederationConfig\n  ) {}\n\n  /**\n   * Create a new federation instance with simplified configuration\n   */\n  static async create(config: SimplifiedFederationConfig): Promise<Federation> {\n    const layer = Layer.mergeAll(FederationComposerLive, FederationLoggerLive, FederationConfigLive)\n\n    const effect = Effect.gen(function* () {\n      // Convert string services to ServiceDefinition\n      const services: ServiceDefinition[] = config.services.map((service, index) =>\n        typeof service === 'string' ? { id: `service-${index}`, url: service } : service\n      )\n\n      // Create full configuration\n      const fullConfig: FederationCompositionConfig = {\n        entities: config.entities,\n        services,\n        errorBoundaries: {\n          subgraphTimeouts: Object.fromEntries(\n            services.map(s => [s.id, Duration.seconds(config.resilience?.timeoutSeconds ?? 30)])\n          ),\n          circuitBreakerConfig: {\n            failureThreshold: config.resilience?.maxFailures ?? 5,\n            resetTimeout: Duration.seconds(30),\n          },\n          partialFailureHandling: {\n            allowPartialFailure: true,\n            criticalSubgraphs: [],\n          },\n          errorTransformation: {\n            sanitizeErrors: true,\n            includeStackTrace: config.development?.logLevel === 'debug',\n          },\n        },\n        performance: {\n          queryPlanCache: {\n            maxSize: config.performance?.cacheSize ?? 1000,\n            ttl: Duration.minutes(30),\n          },\n          dataLoaderConfig: {\n            maxBatchSize: config.performance?.batchSize ?? 100,\n            batchWindowMs: 10,\n            enableBatchLogging: config.development?.logLevel === 'debug',\n          },\n          metricsCollection: {\n            enabled: config.performance?.enableMetrics ?? false,\n            collectExecutionMetrics: true,\n            collectCacheMetrics: true,\n          },\n        },\n      }\n\n      // Compose schema using FederationComposer\n      const composer = yield* FederationComposer\n      const result = yield* composer.compose(fullConfig)\n\n      return new Federation(result.schema, config)\n    })\n\n    const providedEffect = Effect.provide(effect, layer)\n    return Effect.runPromise(providedEffect)\n  }\n\n  /**\n   * Create a simplified entity builder\n   */\n  static createEntity<A = unknown, I = A, R = never>(\n    config: SimplifiedEntityConfig<A, I, R>\n  ): Effect.Effect<\n    FederationEntity<A, R, I, I, R>,\n    ValidationError | EntityResolutionError,\n    never\n  > {\n    return pipe(\n      Effect.gen(function* () {\n        let builder = new FederationEntityBuilder(\n          config.typename,\n          config.schema as Schema.Schema<Record<string, unknown>, Record<string, unknown>, never>,\n          config.keys\n        )\n\n        // Add shareable fields\n        if (config.shareableFields) {\n          for (const field of config.shareableFields) {\n            builder = builder.withShareableField(field)\n          }\n        }\n\n        // Add inaccessible fields\n        if (config.inaccessibleFields) {\n          for (const field of config.inaccessibleFields) {\n            builder = builder.withInaccessibleField(field)\n          }\n        }\n\n        // Add tagged fields\n        if (config.fieldTags) {\n          for (const [field, tags] of Object.entries(config.fieldTags)) {\n            builder = builder.withTaggedField(field, tags)\n          }\n        }\n\n        // Add reference resolver\n        if (config.resolveReference) {\n          builder = builder.withReferenceResolver(\n            config.resolveReference as EntityReferenceResolver<\n              Record<string, unknown>,\n              Record<string, unknown>,\n              Record<string, unknown>\n            >\n          )\n        }\n\n        return yield* builder.build()\n      }),\n      Effect.map(\n        validatedEntity =>\n          toFederationEntity(\n            validatedEntity as unknown as typeof validatedEntity & { key: string[] },\n            config.resolveReference as unknown as EntityReferenceResolver<\n              Record<string, unknown>,\n              Record<string, unknown>,\n              R\n            >\n          ) as unknown as FederationEntity<A, R, I, I, R>\n      )\n    )\n  }\n\n  /**\n   * Quick entity builder with fluent API\n   */\n  static entity<A = unknown, I = A, R = never>(\n    typename: string,\n    schema: Schema.Schema<A, I, R>\n  ): QuickEntityBuilder<A, I, R> {\n    return new QuickEntityBuilder<A, I, R>(typename, schema)\n  }\n\n  /**\n   * Get the composed GraphQL schema\n   */\n  getSchema(): GraphQLSchema {\n    return this.schema\n  }\n\n  /**\n   * Start the federation (for integration with GraphQL servers)\n   */\n  async start(): Promise<void> {\n    // This would integrate with Apollo Server or other GraphQL servers\n    console.log('ðŸš€ Federation started successfully')\n  }\n\n  /**\n   * Stop the federation\n   */\n  async stop(): Promise<void> {\n    console.log('ðŸ›‘ Federation stopped')\n  }\n}\n\n/**\n * Quick entity builder with fluent API\n */\nexport class QuickEntityBuilder<A = unknown, I = A, R = never> {\n  private readonly config: SimplifiedEntityConfig<A, I, R>\n\n  constructor(typename: string, schema: Schema.Schema<A, I, R>) {\n    this.config = {\n      typename,\n      schema,\n      keys: [],\n    }\n  }\n\n  /**\n   * Set key fields\n   */\n  keys(...fields: string[]): this {\n    this.config.keys = fields\n    return this\n  }\n\n  /**\n   * Mark fields as shareable\n   */\n  shareable(...fields: string[]): this {\n    this.config.shareableFields = [...(this.config.shareableFields ?? []), ...fields]\n    return this\n  }\n\n  /**\n   * Mark fields as inaccessible\n   */\n  inaccessible(...fields: string[]): this {\n    this.config.inaccessibleFields = [...(this.config.inaccessibleFields ?? []), ...fields]\n    return this\n  }\n\n  /**\n   * Tag a field\n   */\n  tag(field: string, ...tags: string[]): this {\n    this.config.fieldTags = {\n      ...this.config.fieldTags,\n      [field]: tags,\n    }\n    return this\n  }\n\n  /**\n   * Set reference resolver\n   */\n  resolver(\n    fn: (reference: unknown) => Effect.Effect<A | null, EntityResolutionError, never>\n  ): this {\n    this.config.resolveReference = fn\n    return this\n  }\n\n  /**\n   * Build the entity\n   */\n  build(): Effect.Effect<\n    FederationEntity<A, R, I, I, R>,\n    ValidationError | EntityResolutionError,\n    never\n  > {\n    return Federation.createEntity(this.config)\n  }\n}\n\n/**\n * Preset configurations for common scenarios\n */\nexport const Presets = {\n  /**\n   * Development configuration with hot reload and debug logging\n   */\n  development: (\n    entities: FederationEntity<unknown, unknown, unknown, unknown, Record<string, unknown>>[],\n    services: string[]\n  ): SimplifiedFederationConfig => ({\n    entities,\n    services,\n    performance: {\n      cacheSize: 100,\n      batchSize: 10,\n      enableMetrics: true,\n    },\n    resilience: {\n      enableCircuitBreakers: false,\n      timeoutSeconds: 60,\n      maxFailures: 10,\n    },\n    development: {\n      enableHotReload: true,\n      logLevel: 'debug',\n      enableDevTools: true,\n    },\n  }),\n\n  /**\n   * Production configuration with optimizations\n   */\n  production: (\n    entities: FederationEntity<unknown, unknown, unknown, unknown, Record<string, unknown>>[],\n    services: string[]\n  ): SimplifiedFederationConfig => ({\n    entities,\n    services,\n    performance: {\n      cacheSize: 10000,\n      batchSize: 1000,\n      enableMetrics: true,\n    },\n    resilience: {\n      enableCircuitBreakers: true,\n      timeoutSeconds: 30,\n      maxFailures: 5,\n    },\n    development: {\n      enableHotReload: false,\n      logLevel: 'warn',\n      enableDevTools: false,\n    },\n  }),\n\n  /**\n   * Testing configuration with minimal setup\n   */\n  testing: (\n    entities: FederationEntity<unknown, unknown, unknown, unknown>[]\n  ): SimplifiedFederationConfig => ({\n    entities,\n    services: [{ id: 'mock-service', url: 'http://localhost:4001' }],\n    performance: {\n      cacheSize: 10,\n      batchSize: 5,\n      enableMetrics: false,\n    },\n    resilience: {\n      enableCircuitBreakers: false,\n      timeoutSeconds: 5,\n      maxFailures: 1,\n    },\n    development: {\n      enableHotReload: false,\n      logLevel: 'error',\n      enableDevTools: false,\n    },\n  }),\n}\n\n/**\n * Export common patterns as ready-to-use functions\n */\nexport const Patterns = {\n  /**\n   * Create a basic federated entity\n   */\n  createBasicEntity: <A = unknown>(\n    typename: string,\n    schema: Schema.Schema<A, unknown, never>,\n    keyField: string = 'id'\n  ) => Federation.entity(typename, schema).keys(keyField).build(),\n\n  /**\n   * Create a shareable entity\n   */\n  createShareableEntity: <A = unknown>(\n    typename: string,\n    schema: Schema.Schema<A, unknown, never>,\n    keyField: string,\n    shareableFields: string[]\n  ) =>\n    Federation.entity(typename, schema)\n      .keys(keyField)\n      .shareable(...shareableFields)\n      .build(),\n\n  /**\n   * Create an entity with PII field protection\n   */\n  createPIIEntity: <A = unknown>(\n    typename: string,\n    schema: Schema.Schema<A, unknown, A>,\n    keyField: string,\n    piiFields: string[]\n  ) =>\n    Federation.entity(typename, schema as Schema.Schema<A, unknown, never>)\n      .keys(keyField)\n      .inaccessible(...piiFields)\n      .build(),\n}\n\n// Re-export key types and utilities for convenience\nexport { FederationEntityBuilder, createEntityBuilder } from '../../runtime/core/builders/entity-builder.js'\nexport type { FederationEntity, ServiceDefinition, EntityResolutionError } from '../../runtime/core/types/types.js'\nexport { SubgraphManagement } from '../../federation/subgraphs/subgraph.js'\nexport { FederationErrorBoundaries } from '../../infrastructure/resilience/error-boundaries.js'\nexport { PerformanceOptimizations } from '../../infrastructure/performance/performance.js'\n","/**\n * Ultra-Strict Entity Builder with Pattern Matching\n *\n * This module implements the UltraStrictEntityBuilder that provides:\n * - Discriminated union for entity validation results\n * - Exhaustive pattern matching over validation scenarios\n * - Type-safe fluent interface with compile-time validation\n * - Zero-cost abstractions through phantom types\n */\n\nimport * as Data from 'effect/Data'\nimport * as Effect from 'effect/Effect'\nimport { pipe } from 'effect/Function'\nimport * as Match from 'effect/Match'\nimport * as Schema from 'effect/Schema'\nimport type { GraphQLFieldResolver, GraphQLOutputType } from 'graphql'\n\n// ============================================================================\n// Core Types and Phantom Type System\n// ============================================================================\n\n/**\n * Phantom type markers for compile-time validation states\n *\n * These phantom types ensure that the builder methods can only be called\n * in the correct order, providing compile-time guarantees about builder state.\n *\n * State transition flow:\n * Unvalidated -> HasSchema -> HasKeys -> HasDirectives -> Complete\n *\n * @example\n * ```typescript\n * const builder = UltraStrictEntityBuilder.create('User')  // Unvalidated\n *   .pipe(withSchema(UserSchema))                          // HasSchema\n *   .pipe(withKeys([UltraStrictEntityBuilder.Key.create('id', GraphQLID)]))    // HasKeys\n *   .pipe(withDirectives([]))                              // HasDirectives\n *   .pipe(withResolvers({}))                               // Complete\n * ```\n */\nexport namespace PhantomStates {\n  /** Initial state - no configuration applied yet */\n  export interface Unvalidated {\n    readonly _tag: 'Unvalidated'\n  }\n\n  /** Schema has been defined and validated */\n  export interface HasSchema {\n    readonly _tag: 'HasSchema'\n  }\n\n  /** Entity keys have been defined and validated */\n  export interface HasKeys {\n    readonly _tag: 'HasKeys'\n  }\n\n  /** Federation directives have been applied */\n  export interface HasDirectives {\n    readonly _tag: 'HasDirectives'\n  }\n\n  /** Builder is complete and ready for validation */\n  export interface Complete {\n    readonly _tag: 'Complete'\n  }\n}\n\n/**\n * Entity validation result discriminated union\n */\nexport type EntityValidationResult<A, I, R> = Data.TaggedEnum<{\n  readonly Valid: {\n    readonly entity: ValidatedEntity<A, I, R>\n    readonly metadata: EntityMetadata\n  }\n  readonly InvalidSchema: {\n    readonly errors: readonly SchemaValidationError[]\n    readonly partialEntity?: Partial<ValidatedEntity<A, I, R>>\n  }\n  readonly InvalidKeys: {\n    readonly errors: readonly KeyValidationError[]\n    readonly schema: Schema.Schema<A, I, R>\n  }\n  readonly InvalidDirectives: {\n    readonly errors: readonly DirectiveValidationError[]\n    readonly schema: Schema.Schema<A, I, R>\n    readonly keys: readonly EntityKey[]\n  }\n  readonly CircularDependency: {\n    readonly cycle: readonly string[]\n    readonly involvedEntities: readonly string[]\n  }\n  readonly IncompatibleVersion: {\n    readonly requiredVersion: string\n    readonly currentVersion: string\n    readonly entity: string\n  }\n}>\n\n// Create a base result type for unknown generics to avoid using any\ntype BaseEntityValidationResult = EntityValidationResult<unknown, unknown, unknown>\n\n// Create the tagged enum constructor with proper typing\nexport const EntityValidationResult = Data.taggedEnum<BaseEntityValidationResult>() as {\n  readonly Valid: <A, I, R>(args: {\n    readonly entity: ValidatedEntity<A, I, R>\n    readonly metadata: EntityMetadata\n  }) => EntityValidationResult<A, I, R>\n  readonly InvalidSchema: <A, I, R>(args: {\n    readonly errors: readonly SchemaValidationError[]\n    readonly partialEntity?: Partial<ValidatedEntity<A, I, R>>\n  }) => EntityValidationResult<A, I, R>\n  readonly InvalidKeys: <A, I, R>(args: {\n    readonly errors: readonly KeyValidationError[]\n    readonly schema: Schema.Schema<A, I, R>\n  }) => EntityValidationResult<A, I, R>\n  readonly InvalidDirectives: <A, I, R>(args: {\n    readonly errors: readonly DirectiveValidationError[]\n    readonly schema: Schema.Schema<A, I, R>\n    readonly keys: readonly EntityKey[]\n  }) => EntityValidationResult<A, I, R>\n  readonly CircularDependency: <A, I, R>(args: {\n    readonly cycle: readonly string[]\n    readonly involvedEntities: readonly string[]\n  }) => EntityValidationResult<A, I, R>\n  readonly IncompatibleVersion: <A, I, R>(args: {\n    readonly requiredVersion: string\n    readonly currentVersion: string\n    readonly entity: string\n  }) => EntityValidationResult<A, I, R>\n}\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\n/**\n * Schema validation error for ultra-strict entity builder\n * @category Experimental\n */\nexport class SchemaValidationError extends Data.TaggedError('SchemaValidationError')<{\n  readonly message: string\n  readonly schemaPath: readonly string[]\n  readonly suggestion?: string\n}> {}\n\n/**\n * Key validation error for ultra-strict entity builder\n * @category Experimental\n */\nexport class KeyValidationError extends Data.TaggedError('KeyValidationError')<{\n  readonly message: string\n  readonly keyField: string\n  readonly entityType: string\n  readonly suggestion?: string\n}> {}\n\n/**\n * Directive validation error for ultra-strict entity builder\n * @category Experimental\n */\nexport class DirectiveValidationError extends Data.TaggedError('DirectiveValidationError')<{\n  readonly message: string\n  readonly directive: string\n  readonly field?: string\n  readonly suggestion?: string\n}> {}\n\n/**\n * Entity builder error for ultra-strict entity builder\n * @category Experimental\n */\nexport class EntityBuilderError extends Data.TaggedError('EntityBuilderError')<{\n  readonly message: string\n  readonly builderState: string\n  readonly suggestion?: string\n}> {}\n\n// ============================================================================\n// Entity Types\n// ============================================================================\n\n/**\n * Entity key definition for ultra-strict entity builder\n * @category Experimental\n */\nexport interface EntityKey {\n  readonly field: string\n  readonly type: GraphQLOutputType\n  readonly isComposite: boolean\n}\n\n/**\n * Entity directive definition for ultra-strict entity builder\n * @category Experimental\n */\nexport interface EntityDirective {\n  readonly name: string\n  readonly args: Record<string, unknown>\n  readonly applicableFields?: readonly string[] | undefined\n}\n\n/**\n * Entity metadata for ultra-strict entity builder\n * @category Experimental\n */\nexport interface EntityMetadata {\n  readonly typename: string\n  readonly version: string\n  readonly createdAt: Date\n  readonly validationLevel: 'strict' | 'ultra-strict'\n  readonly dependencies: readonly string[]\n}\n\n/**\n * Validated entity for ultra-strict entity builder\n * @category Experimental\n */\nexport interface ValidatedEntity<A, I, R> {\n  readonly typename: string\n  readonly schema: Schema.Schema<A, I, R>\n  readonly keys: readonly EntityKey[]\n  readonly directives: readonly EntityDirective[]\n  readonly resolvers: Record<string, GraphQLFieldResolver<A, I, R>>\n  readonly metadata: EntityMetadata\n}\n\n// ============================================================================\n// Ultra-Strict Entity Builder with Phantom Types\n// ============================================================================\n\nexport interface UltraStrictEntityBuilder<\n  TState extends\n    | PhantomStates.Unvalidated\n    | PhantomStates.HasSchema\n    | PhantomStates.HasKeys\n    | PhantomStates.HasDirectives\n    | PhantomStates.Complete,\n  A = unknown,\n  I = A,\n  R = never,\n> {\n  readonly _phantomState: TState\n  readonly typename: string\n  readonly schema: Schema.Schema<A, I, R>\n  readonly keys?: readonly EntityKey[]\n  readonly directives?: readonly EntityDirective[]\n  readonly resolvers?: Record<string, GraphQLFieldResolver<A, I, R>>\n}\n\n/**\n * Creates a new UltraStrictEntityBuilder with compile-time state tracking\n *\n * The builder uses phantom types to enforce correct usage order at compile time.\n * This prevents runtime errors by catching configuration mistakes during development.\n *\n * @param typename - The GraphQL type name for this entity\n * @returns Builder in Unvalidated state, requiring schema definition next\n *\n * @example\n * ```typescript\n * const userBuilder = createUltraStrictEntityBuilder('User')\n * // Next step must be withSchema - compiler enforces this\n * ```\n */\nexport const createUltraStrictEntityBuilder = <A = unknown, I = A, R = never>(\n  typename: string,\n  schema: Schema.Schema<A, I, R>\n): UltraStrictEntityBuilder<PhantomStates.HasSchema, A, I, R> => {\n  if (!typename?.trim()) {\n    throw new Error('Entity typename cannot be empty')\n  }\n\n  return {\n    _phantomState: Data.struct({ _tag: 'HasSchema' as const }),\n    typename,\n    schema,\n  }\n}\n\n/**\n * Type-safe schema attachment (only valid in Unvalidated state)\n *\n * Attaches an Effect Schema to the entity for runtime validation.\n * The phantom type system ensures this can only be called on an unvalidated builder.\n *\n * @template A - The schema type being attached\n * @param schema - Effect Schema instance for validation\n * @returns Function that takes Unvalidated builder and returns HasSchema builder\n *\n * @example\n * ```typescript\n * const UserSchema = Schema.Struct({\n *   id: Schema.String,\n *   name: Schema.String,\n *   email: Schema.String\n * })\n *\n * const builderWithSchema = createUltraStrictEntityBuilder('User')\n *   .pipe(withSchema(UserSchema))\n * ```\n */\nexport const withSchema =\n  <A = unknown, I = A, R = never>(schema?: Schema.Schema<A, I, R>) =>\n  (\n    builder: UltraStrictEntityBuilder<PhantomStates.Unvalidated, A, I, R>\n  ): UltraStrictEntityBuilder<PhantomStates.HasSchema, A, I, R> => {\n    if (!schema) {\n      throw new Error('Schema cannot be null or undefined')\n    }\n\n    return {\n      ...builder,\n      _phantomState: Data.struct({ _tag: 'HasSchema' as const }),\n      schema,\n    }\n  }\n\n/**\n * Type-safe key definition (only valid in HasSchema state)\n *\n * Defines the key fields that uniquely identify this entity across subgraphs.\n * The phantom type system ensures schema is attached before keys can be defined.\n *\n * @param keys - Array of EntityKey objects defining the unique identifier(s)\n * @returns Function that takes HasSchema builder and returns HasKeys builder\n *\n * @example\n * ```typescript\n * const keys = [\n *   UltraStrictEntityBuilder.Key.create('id', GraphQLID, false),\n *   UltraStrictEntityBuilder.Key.create('organizationId', GraphQLID, false) // Composite key\n * ]\n *\n * const builderWithKeys = builderWithSchema\n *   .pipe(withKeys(keys))\n * ```\n */\nexport const withKeys =\n  <A = unknown, I = A, R = never>(keys?: readonly EntityKey[]) =>\n  (\n    builder: UltraStrictEntityBuilder<PhantomStates.HasSchema, A, I, R>\n  ): UltraStrictEntityBuilder<PhantomStates.HasKeys, A, I, R> => {\n    // Allow empty keys to be set, validation will catch this later\n    const actualKeys = keys ?? []\n\n    // Validate key field names (only if keys exist)\n    if (actualKeys.length > 0) {\n      const duplicateKeys = actualKeys\n        .map(k => k.field)\n        .filter((field, index, arr) => arr.indexOf(field) !== index)\n\n      if (duplicateKeys.length > 0) {\n        throw new Error(`Duplicate key fields found: ${duplicateKeys.join(', ')}`)\n      }\n    }\n\n    return {\n      ...builder,\n      _phantomState: Data.struct({ _tag: 'HasKeys' as const }),\n      keys: actualKeys,\n    }\n  }\n\n/**\n * Type-safe directive application (only valid in HasKeys state)\n *\n * Applies Federation directives to the entity. The phantom type system ensures\n * both schema and keys are defined before directives can be applied.\n *\n * @param directives - Array of Federation directives (@shareable, @inaccessible, etc.)\n * @returns Function that takes HasKeys builder and returns HasDirectives builder\n *\n * @example\n * ```typescript\n * const directives = [\n *   UltraStrictEntityBuilder.Directive.shareable(),\n *   UltraStrictEntityBuilder.Directive.tag('public'),\n *   UltraStrictEntityBuilder.Directive.provides('email')\n * ]\n *\n * const builderWithDirectives = builderWithKeys\n *   .pipe(withDirectives(directives))\n * ```\n */\nexport const withDirectives =\n  <A = unknown, I = A, R = never>(directives?: readonly EntityDirective[]) =>\n  (\n    builder: UltraStrictEntityBuilder<PhantomStates.HasKeys, A, I, R>\n  ): UltraStrictEntityBuilder<PhantomStates.HasDirectives, A, I, R> => {\n    // Validate directive conflicts at compile time\n    const directiveNames = directives?.map(d => d.name) ?? []\n    const conflictingPairs = [\n      ['shareable', 'override'],\n      ['inaccessible', 'shareable'],\n      ['external', 'override'],\n    ] as const\n\n    const hasConflict = conflictingPairs.some(\n      ([dir1, dir2]) => directiveNames.includes(dir1) && directiveNames.includes(dir2)\n    )\n\n    if (hasConflict) {\n      const conflict = conflictingPairs.find(\n        ([dir1, dir2]) => directiveNames.includes(dir1) && directiveNames.includes(dir2)\n      )\n      throw new Error(\n        `Conflicting directives: @${conflict?.[0]} and @${conflict?.[1]} cannot be used together`\n      )\n    }\n\n    return {\n      ...builder,\n      _phantomState: Data.struct({ _tag: 'HasDirectives' as const }),\n      directives: directives ?? [],\n    }\n  }\n\n/**\n * Type-safe resolver attachment (only valid in HasDirectives state)\n *\n * Attaches field resolvers to the entity. The phantom type system ensures\n * all previous configuration steps are complete before resolvers can be attached.\n *\n * @param resolvers - Record of field name to resolver function mappings\n * @returns Function that takes HasDirectives builder and returns Complete builder\n *\n * @example\n * ```typescript\n * const resolvers = {\n *   displayName: (user) => `${user.firstName} ${user.lastName}`,\n *   avatar: (user, args, ctx) => ctx.imageService.getAvatar(user.id),\n *   posts: (user, args, ctx) => ctx.postService.findByUserId(user.id)\n * }\n *\n * const completeBuilder = builderWithDirectives\n *   .pipe(withResolvers(resolvers))\n * ```\n */\nexport const withResolvers =\n  <A = unknown, I = A, R = never>(resolvers?: Record<string, GraphQLFieldResolver<A, I, R>>) =>\n  (\n    builder: UltraStrictEntityBuilder<PhantomStates.HasDirectives, A, I, R>\n  ): UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R> => {\n    if (!resolvers) {\n      throw new Error('Resolvers cannot be null or undefined')\n    }\n\n    // Validate resolver functions\n    const invalidResolvers = Object.entries(resolvers)\n      .filter(([, resolver]) => typeof resolver !== 'function')\n      .map(([fieldName]) => fieldName)\n\n    if (invalidResolvers.length > 0) {\n      throw new Error(`Resolvers for fields '${invalidResolvers.join(', ')}' must be functions`)\n    }\n\n    return {\n      ...builder,\n      _phantomState: Data.struct({ _tag: 'Complete' as const }),\n      resolvers,\n    }\n  }\n\n// ============================================================================\n// Pattern Matching Validation Engine\n// ============================================================================\n\n/**\n * Validates a complete entity builder using exhaustive pattern matching\n */\nexport const validateEntityBuilder = <A = unknown, I = A, R = never>(\n  builder: UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>\n): Effect.Effect<EntityValidationResult<A, I, R>, EntityBuilderError> =>\n  pipe(\n    Effect.succeed(builder),\n    Effect.flatMap(validateSchema),\n    Effect.flatMap(validateKeys),\n    Effect.flatMap(validateDirectives),\n    Effect.flatMap(validateCircularDependencies),\n    Effect.flatMap(validateCompatibility),\n    Effect.map(createValidResult),\n    Effect.catchAll(handleValidationErrors)\n  ) as Effect.Effect<EntityValidationResult<A, I, R>, EntityBuilderError>\n\nconst validateSchema = <A = unknown, I = A, R = never>(\n  builder: UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>\n): Effect.Effect<\n  UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>,\n  readonly SchemaValidationError[]\n> =>\n  pipe(\n    Effect.succeed(builder.schema),\n    Effect.flatMap(schema => {\n      // Just verify the schema exists and is well-formed\n      // We don't try to decode actual data, just validate the schema structure\n      if (schema === undefined) {\n        return Effect.fail([\n          new SchemaValidationError({\n            message: `Schema is required`,\n            schemaPath: ['schema'],\n            suggestion: 'Ensure a valid schema is provided',\n          }),\n        ])\n      }\n      return Effect.succeed(builder)\n    })\n  )\n\nconst validateKeys = <A = unknown, I = A, R = never>(\n  builder: UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>\n): Effect.Effect<\n  UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>,\n  readonly KeyValidationError[]\n> =>\n  pipe(\n    Effect.succeed(builder.keys ?? []),\n    Effect.flatMap(keys => {\n      let errors: KeyValidationError[] = []\n\n      if (keys.length === 0) {\n        errors.push(\n          new KeyValidationError({\n            message: 'Entity must have at least one key field',\n            keyField: '<missing>',\n            entityType: builder.typename,\n            suggestion: \"Add a primary key field like 'id' or composite keys\",\n          })\n        )\n      }\n\n      // Validate key fields exist in schema\n      const schemaFields = getSchemaFields(builder.schema)\n      const missingKeyErrors = keys\n        .filter(key => !schemaFields.includes(key.field))\n        .map(\n          key =>\n            new KeyValidationError({\n              message: `Key field '${key.field}' not found in schema`,\n              keyField: key.field,\n              entityType: builder.typename,\n              suggestion: `Add field '${key.field}' to the schema or remove from keys`,\n            })\n        )\n\n      errors = [...errors, ...missingKeyErrors]\n\n      return errors.length > 0\n        ? Effect.fail(errors as readonly KeyValidationError[])\n        : Effect.succeed(builder)\n    })\n  )\n\nconst validateDirectives = <A = unknown, I = A, R = never>(\n  builder: UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>\n): Effect.Effect<\n  UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>,\n  readonly DirectiveValidationError[]\n> =>\n  pipe(\n    Effect.succeed(builder.directives),\n    Effect.flatMap(directives => {\n      const validDirectives = [\n        'shareable',\n        'inaccessible',\n        'tag',\n        'override',\n        'external',\n        'provides',\n        'requires',\n      ]\n\n      const directiveErrors = (directives ?? []).flatMap(directive => {\n        const errors: DirectiveValidationError[] = []\n\n        if (!validDirectives.includes(directive.name)) {\n          errors.push(\n            new DirectiveValidationError({\n              message: `Unknown Federation directive: @${directive.name}`,\n              directive: directive.name,\n              suggestion: `Use one of: ${validDirectives.map(d => `@${d}`).join(', ')}`,\n            })\n          )\n        }\n\n        // Validate directive-specific rules\n        if (directive.name === 'override' && directive.args?.['from'] === undefined) {\n          errors.push(\n            new DirectiveValidationError({\n              message: \"@override directive requires 'from' argument\",\n              directive: directive.name,\n              suggestion: 'Add \\'from: \"SubgraphName\"\\' to @override directive',\n            })\n          )\n        }\n\n        return errors\n      })\n\n      const allErrors = directiveErrors.flat()\n\n      return allErrors.length > 0\n        ? Effect.fail(allErrors as readonly DirectiveValidationError[])\n        : Effect.succeed(builder)\n    })\n  )\n\nconst validateCircularDependencies = <A = unknown, I = A, R = never>(\n  builder: UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>\n): Effect.Effect<UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>, never> =>\n  Effect.succeed(builder) // Simplified for now - would implement cycle detection\n\nconst validateCompatibility = <A = unknown, I = A, R = never>(\n  builder: UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>\n): Effect.Effect<UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>, never> =>\n  Effect.succeed(builder) // Simplified for now - would validate Federation version compatibility\n\nconst createValidResult = <A = unknown, I = A, R = never>(\n  builder: UltraStrictEntityBuilder<PhantomStates.Complete, A, I, R>\n): EntityValidationResult<A, I, R> => {\n  const result = EntityValidationResult.Valid({\n    entity: {\n      typename: builder.typename,\n      schema: builder.schema,\n      keys: builder.keys ?? [],\n      directives: builder.directives ?? [],\n      resolvers: builder.resolvers ?? {},\n      metadata: {\n        typename: builder.typename,\n        version: '2.0.0',\n        createdAt: new Date(),\n        validationLevel: 'ultra-strict',\n        dependencies: [],\n      },\n    },\n    metadata: {\n      typename: builder.typename,\n      version: '2.0.0',\n      createdAt: new Date(),\n      validationLevel: 'ultra-strict',\n      dependencies: [],\n    },\n  })\n  return result as EntityValidationResult<A, I, R>\n}\n\nconst handleValidationErrors = <A = unknown, I = A, R = never>(\n  errors:\n    | readonly SchemaValidationError[]\n    | readonly KeyValidationError[]\n    | readonly DirectiveValidationError[]\n): Effect.Effect<EntityValidationResult<A, I, R>, never> =>\n  pipe(\n    Match.value(errors),\n    Match.when(\n      (\n        errs: readonly (SchemaValidationError | KeyValidationError | DirectiveValidationError)[]\n      ): errs is readonly SchemaValidationError[] =>\n        errs.length > 0 && errs[0] instanceof SchemaValidationError,\n      (errs: readonly SchemaValidationError[]) => {\n        const result = EntityValidationResult.InvalidSchema({ errors: errs })\n        return Effect.succeed(result as EntityValidationResult<A, I, R>)\n      }\n    ),\n    Match.when(\n      (\n        errs: readonly (SchemaValidationError | KeyValidationError | DirectiveValidationError)[]\n      ): errs is readonly KeyValidationError[] =>\n        errs.length > 0 && errs[0] instanceof KeyValidationError,\n      (errs: readonly KeyValidationError[]) => {\n        const result = EntityValidationResult.InvalidKeys({\n          errors: errs,\n          schema: Schema.Struct({}) as unknown as Schema.Schema<A, I, R>,\n        })\n        return Effect.succeed(result as EntityValidationResult<A, I, R>)\n      }\n    ),\n    Match.when(\n      (\n        errs: readonly (SchemaValidationError | KeyValidationError | DirectiveValidationError)[]\n      ): errs is readonly DirectiveValidationError[] =>\n        errs.length > 0 && errs[0] instanceof DirectiveValidationError,\n      (errs: readonly DirectiveValidationError[]) => {\n        const result = EntityValidationResult.InvalidDirectives({\n          errors: errs,\n          schema: Schema.Struct({}) as unknown as Schema.Schema<A, I, R>,\n          keys: [],\n        })\n        return Effect.succeed(result as EntityValidationResult<A, I, R>)\n      }\n    ),\n    Match.exhaustive\n  )\n\n// ============================================================================\n// Pattern Matching Result Handler\n// ============================================================================\n\n/**\n * Exhaustive pattern matching over entity validation results\n */\nexport const matchEntityValidationResult =\n  <A, I, R>(handlers: {\n    readonly Valid: (data: {\n      readonly entity: ValidatedEntity<A, I, R>\n      readonly metadata: EntityMetadata\n    }) => A\n    readonly InvalidSchema: (data: {\n      readonly errors: readonly SchemaValidationError[]\n      readonly partialEntity?: Partial<ValidatedEntity<A, I, R>>\n    }) => A\n    readonly InvalidKeys: (data: {\n      readonly errors: readonly KeyValidationError[]\n      readonly schema: Schema.Schema<A, I, R>\n    }) => A\n    readonly InvalidDirectives: (data: {\n      readonly errors: readonly DirectiveValidationError[]\n      readonly schema: Schema.Schema<A, I, R>\n      readonly keys: readonly EntityKey[]\n    }) => A\n    readonly CircularDependency: (data: {\n      readonly cycle: readonly string[]\n      readonly involvedEntities: readonly string[]\n    }) => A\n    readonly IncompatibleVersion: (data: {\n      readonly requiredVersion: string\n      readonly currentVersion: string\n      readonly entity: string\n    }) => A\n  }) =>\n  (result: EntityValidationResult<A, I, R>): A =>\n    Match.value(result).pipe(\n      Match.tag('Valid', handlers.Valid),\n      Match.tag('InvalidSchema', handlers.InvalidSchema),\n      Match.tag('InvalidKeys', handlers.InvalidKeys),\n      Match.tag('InvalidDirectives', handlers.InvalidDirectives),\n      Match.tag('CircularDependency', handlers.CircularDependency),\n      Match.tag('IncompatibleVersion', handlers.IncompatibleVersion),\n      Match.exhaustive\n    ) as A\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\nconst getSchemaFields = <A = unknown, I = A, R = never>(\n  schema: Schema.Schema<A, I, R>\n): readonly string[] => {\n  const ast = schema.ast\n\n  // Handle struct schemas which are the most common for entities\n  if (ast._tag === 'TypeLiteral') {\n    return ast.propertySignatures.map(prop => {\n      if (typeof prop.name === 'string') {\n        return prop.name\n      }\n      // Handle symbol keys by converting to string\n      return String(prop.name)\n    })\n  }\n\n  // For other schema types, we can't extract fields\n  // This is fine as the validation will catch it\n  return []\n}\n\n// ============================================================================\n// Entity Key and Directive Utilities\n// ============================================================================\n\n/**\n * Creates an entity key for federation (internal implementation)\n */\nconst createEntityKey = (\n  field: string,\n  type: GraphQLOutputType,\n  isComposite = false\n): EntityKey => ({\n  field,\n  type,\n  isComposite,\n})\n\n/**\n * UltraStrictEntityBuilder namespace with static utilities\n *\n * This provides the expected API surface that tests and examples use\n */\nexport namespace UltraStrictEntityBuilder {\n  /**\n   * Directive utilities namespace for creating federation directives\n   */\n  export namespace Directive {\n    export const shareable = (): EntityDirective => ({\n      name: 'shareable',\n      args: {},\n    })\n\n    export const inaccessible = (): EntityDirective => ({\n      name: 'inaccessible',\n      args: {},\n    })\n\n    export const tag = (name: string): EntityDirective => ({\n      name: 'tag',\n      args: { name },\n    })\n\n    export const override = (from: string): EntityDirective => ({\n      name: 'override',\n      args: { from },\n    })\n\n    export const external = (): EntityDirective => ({\n      name: 'external',\n      args: {},\n    })\n\n    export const provides = (fields: string): EntityDirective => ({\n      name: 'provides',\n      args: { fields },\n    })\n\n    export const requires = (fields: string): EntityDirective => ({\n      name: 'requires',\n      args: { fields },\n    })\n  }\n\n  /**\n   * Key utilities namespace for creating entity keys\n   */\n  export namespace Key {\n    export const create = createEntityKey\n  }\n}\n","/**\n * Experimental Features Module - Advanced TypeScript Patterns and Ultra-Strict Entity Builders\n *\n * This module contains cutting-edge TypeScript patterns, experimental features, and ultra-strict\n * entity builders that demonstrate the framework's advanced capabilities. These features provide\n * compile-time guarantees, phantom types, and sophisticated pattern matching for maximum type safety.\n *\n * ## ðŸ§ª Experimental Features Overview\n *\n * ### Ultra-Strict Entity Builder\n * A compile-time validated entity builder using phantom types to enforce correct construction order:\n * - **Phantom Types**: State machine enforced at compile time\n * - **Discriminated Unions**: Exhaustive pattern matching over validation results\n * - **Zero-Cost Abstractions**: Runtime performance with compile-time safety\n * - **Type-Safe Pipelines**: Fluent API that prevents invalid state transitions\n *\n * ### Advanced Pattern Matching\n * Comprehensive pattern matching system for handling complex validation scenarios:\n * - **Exhaustive Matching**: Compiler-enforced handling of all cases\n * - **Tagged Unions**: Type-safe discriminated union handling\n * - **Error Correlation**: Rich error context and suggestion system\n * - **Validation Pipelines**: Composable validation with detailed error reporting\n *\n * ## ðŸŽ¯ When to Use Experimental Features\n *\n * ### Use Ultra-Strict Builder When:\n * - **Maximum Type Safety**: Critical systems requiring compile-time validation\n * - **Complex Entity Rules**: Entities with sophisticated validation requirements\n * - **Team Enforcement**: Large teams needing guardrails against invalid configurations\n * - **Schema Evolution**: Entities that frequently change and need migration safety\n *\n * ### Use Standard Builder When:\n * - **Rapid Development**: Prototyping and quick iteration scenarios\n * - **Simple Entities**: Straightforward entities without complex validation needs\n * - **Learning Phase**: Teams new to the framework or Effect-TS patterns\n * - **Dynamic Configurations**: Runtime entity construction from external sources\n *\n * ## âš ï¸ Experimental Status\n *\n * These features are marked experimental because:\n * - **API Evolution**: APIs may change in future versions\n * - **Performance Impact**: Additional compile-time checks may slow TypeScript compilation\n * - **Complexity Trade-offs**: Added type safety comes with learning curve overhead\n * - **Ecosystem Maturity**: Integration with tooling may be limited\n *\n * ## ðŸš€ Usage Comparison\n *\n * Comparing standard and ultra-strict builder approaches:\n *\n * ```typescript\n * // Standard builder\n * const entity = createEntityBuilder('User', UserSchema, ['id'])\n *   .withShareableField('name')\n *   .withReferenceResolver(resolveUser)\n *   .build()\n *\n * // Ultra-strict builder\n * const entity = createUltraStrictEntityBuilder('User')\n *   .pipe(withSchema(UserSchema))\n *   .pipe(withKeys([UltraStrictEntityBuilder.Key.create('id', GraphQLID)]))\n *   .pipe(withDirectives([UltraStrictEntityBuilder.Directive.shareable()]))\n *   .pipe(withResolvers({ __resolveReference: resolveUser }))\n * ```\n *\n * @example Ultra-strict entity with comprehensive validation\n * ```typescript\n * import {\n *   createUltraStrictEntityBuilder,\n *   withSchema,\n *   withKeys,\n *   withDirectives,\n *   withResolvers,\n *   validateEntityBuilder,\n *   matchEntityValidationResult,\n *   UltraStrictEntityBuilder\n * } from '@cqrs/federation/experimental'\n *\n * const UserSchema = Schema.Struct({\n *   id: Schema.String,\n *   email: Schema.String,\n *   name: Schema.String,\n *   organizationId: Schema.String\n * })\n *\n * const buildUserEntity = Effect.gen(function* () {\n *   // Step 1: Build entity with compile-time state validation\n *   const builder = createUltraStrictEntityBuilder('User')\n *     .pipe(withSchema(UserSchema))\n *     .pipe(withKeys([\n *       UltraStrictEntityBuilder.Key.create('id', GraphQLID),\n *       UltraStrictEntityBuilder.Key.create('organizationId', GraphQLID) // Composite key\n *     ]))\n *     .pipe(withDirectives([\n *       UltraStrictEntityBuilder.Directive.shareable(),\n *       UltraStrictEntityBuilder.Directive.tag('public'),\n *       UltraStrictEntityBuilder.Directive.requires('organizationId')\n *     ]))\n *     .pipe(withResolvers({\n *       __resolveReference: resolveUserReference,\n *       displayName: resolveDisplayName,\n *       avatar: resolveAvatar\n *     }))\n *\n *   // Step 2: Validate with exhaustive pattern matching\n *   const validation = yield* validateEntityBuilder(builder)\n *\n *   return matchEntityValidationResult({\n *     Valid: ({ entity, metadata }) => {\n *       console.log(`âœ… Entity validated successfully: ${entity.typename}`)\n *       return entity\n *     },\n *     InvalidSchema: ({ errors }) => {\n *       const errorMessages = errors.map(e => `Schema error: ${e.message}`)\n *       throw new Error(`Schema validation failed:\\n${errorMessages.join('\\n')}`)\n *     },\n *     InvalidKeys: ({ errors, schema }) => {\n *       const suggestions = errors.map(e => e.suggestion).filter(Boolean)\n *       throw new Error(`Key validation failed. Suggestions: ${suggestions.join(', ')}`)\n *     },\n *     InvalidDirectives: ({ errors }) => {\n *       const conflicts = errors.filter(e => e.message.includes('conflict'))\n *       throw new Error(`Directive conflicts detected: ${conflicts.map(e => e.message).join(', ')}`)\n *     },\n *     CircularDependency: ({ cycle, involvedEntities }) => {\n *       throw new Error(`Circular dependency detected: ${cycle.join(' -> ')}`)\n *     },\n *     IncompatibleVersion: ({ requiredVersion, currentVersion, entity }) => {\n *       throw new Error(`Version mismatch for ${entity}: requires ${requiredVersion}, got ${currentVersion}`)\n *     }\n *   })(validation)\n * })\n * ```\n *\n * @example Error handling with rich context\n * ```typescript\n * const handleEntityValidation = (result: EntityValidationResult) =>\n *   matchEntityValidationResult({\n *     Valid: ({ entity }) =>\n *       Effect.succeed(`Entity ${entity.typename} is ready for federation`),\n *\n *     InvalidSchema: ({ errors, partialEntity }) =>\n *       Effect.gen(function* () {\n *         const logger = yield* FederationLogger\n *\n *         yield* logger.error('Schema validation failed', {\n *           errors: errors.map(e => ({\n *             message: e.message,\n *             path: e.schemaPath,\n *             suggestion: e.suggestion\n *           }))\n *         })\n *\n *         // Attempt partial recovery if possible\n *         if (partialEntity) {\n *           yield* logger.warn('Attempting partial entity recovery', {\n *             availableFields: Object.keys(partialEntity)\n *           })\n *         }\n *\n *         return yield* Effect.fail(new ValidationError(\n *           `Schema validation failed: ${errors.map(e => e.message).join(', ')}`,\n *           'schema'\n *         ))\n *       }),\n *\n *     InvalidKeys: ({ errors, schema }) =>\n *       Effect.gen(function* () {\n *         const logger = yield* FederationLogger\n *\n *         yield* logger.error('Key validation failed', {\n *           missingKeys: errors.filter(e => e.message.includes('not found')),\n *           suggestions: errors.map(e => e.suggestion).filter(Boolean)\n *         })\n *\n *         return yield* Effect.fail(new ValidationError(\n *           'Entity key validation failed',\n *           'keys',\n *           errors.map(e => e.keyField)\n *         ))\n *       }),\n *\n *     InvalidDirectives: ({ errors }) =>\n *       Effect.fail(new ValidationError(\n *         `Directive validation failed: ${errors.map(e =>\n *           `@${e.directive}${e.field ? ` on ${e.field}` : ''}: ${e.message}`\n *         ).join(', ')}`,\n *         'directives'\n *       )),\n *\n *     CircularDependency: ({ cycle }) =>\n *       Effect.fail(new CompositionError(\n *         `Circular dependency in entity relationships: ${cycle.join(' -> ')}`\n *       )),\n *\n *     IncompatibleVersion: ({ requiredVersion, currentVersion, entity }) =>\n *       Effect.fail(new CompositionError(\n *         `Federation version mismatch for entity ${entity}: requires ${requiredVersion} but found ${currentVersion}`\n *       ))\n *   })(result)\n * ```\n *\n * @example Advanced phantom type usage\n * ```typescript\n * // Phantom types prevent invalid builder usage at compile time\n * const invalidBuilder = createUltraStrictEntityBuilder('Product')\n *   // .pipe(withKeys([...])) // âŒ Compile error: keys require schema first\n *\n * const validBuilder = createUltraStrictEntityBuilder('Product')\n *   .pipe(withSchema(ProductSchema))     // âœ… Schema first\n *   .pipe(withKeys([                     // âœ… Then keys\n *     UltraStrictEntityBuilder.Key.create('id', GraphQLID),\n *     UltraStrictEntityBuilder.Key.create('sku', GraphQLString)\n *   ]))\n *   .pipe(withDirectives([               // âœ… Then directives\n *     UltraStrictEntityBuilder.Directive.shareable(),\n *     UltraStrictEntityBuilder.Directive.tag('inventory')\n *   ]))\n *   .pipe(withResolvers({                // âœ… Finally resolvers\n *     __resolveReference: resolveProduct,\n *     price: resolvePricing,\n *     availability: resolveInventory\n *   }))\n * ```\n *\n * @category Experimental Features\n * @experimental\n * @see {@link UltraStrictEntityBuilder} - Ultra-strict entity builder with phantom types\n * @see {@link EntityValidationResult} - Discriminated union for validation results\n * @see {@link https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html | TypeScript Advanced Types}\n */\n\nexport {\n  createUltraStrictEntityBuilder,\n  DirectiveValidationError,\n  EntityBuilderError,\n  type EntityDirective,\n  type EntityKey,\n  type EntityMetadata,\n  type EntityValidationResult,\n  KeyValidationError,\n  matchEntityValidationResult,\n  type PhantomStates,\n  SchemaValidationError,\n  UltraStrictEntityBuilder,\n  type ValidatedEntity,\n  validateEntityBuilder,\n  withDirectives,\n  withKeys,\n  withResolvers,\n  withSchema,\n} from './strict.js'\n","/**\n * API Module - User-facing APIs\n * \n * This module provides different API levels for various use cases:\n * - Simple: Facade API for quick setup without Effect-TS complexity\n * - Advanced: Experimental patterns with phantom types\n * - Patterns: Library of common federation patterns\n * \n * @module API\n * @since 3.0.0\n */\n\n// Simple API (Facade pattern)\nexport * from './simple'\n\n// Advanced patterns (Experimental)\nexport * as Advanced from './advanced'\n\n// Pattern library (when implemented)\n// export * as Patterns from './patterns'"],"mappings":"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"}